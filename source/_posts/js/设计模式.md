---
title: 设计模式
date: 2020-11-28 20:37:50
categories: JS
top: false
summary: 设计模式
tags: 
 - JS
---

### 程序设计

### 一、设计原则

什么是设计？

* 按哪一种思路或者标准来实现功能
* 功能相同，可以有不同设计的方式
* 需求如果不断变化，设计的作用才体现出来

7大设计原则

| 首字母 | 指代         | 概念                                                         |
| ------ | ------------ | ------------------------------------------------------------ |
| S      | 单一职责原则 | 单一功能原则认为对象应该仅具有一种单一功能的概念**（类的方法要单一）** |
| O      | 开放封闭原则 | 开闭原则认为“软件体应该是对于扩展开放的，但是对于修改是封闭的”**（新需求在原有的代码上进行扩展，而不是去修改）** |
| L      | 里氏替换原则 | 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换”的概念。参考 契约式设计**（能用父类的地方也能用子类）** |
| I      | 接口隔离原则 | 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途接口”的概念**（一个接口执行一个单一的功能）** |
| D      | 依赖倒置原则 | 依赖倒置原则认为一个方法应该遵从“依赖抽象而不是一个实例”的原则。依赖注入是该原则的一种实现方式**（多用抽象接口而不用继承，继承是强耦合的体现）** |
| L      | 迪米特法则   | 一个软件实体应当尽可能少与其他实体发生相互作用，降低实体间的耦合性**（类与类之间的关联不能太多 例如1对n，不然就代码编强耦合）** |
| C      | 合成复用原则 | 尽量使用对象组合，而不是继承来达到复用的目的**（类与类之间关系多用组合）** |

#### 1.1 单一职责原则

* Single responsibility principle
* 一个出现只做好一件事
* 如果功能特别负责就要进行拆分

> 例如下面的 更新名字，更新价格，更新分类都拆分为一个个独立的方法

```typescript
/**
 * 单一职责
 * 一个类的功能要尽可能单一，不要太杂
 * 如果一个类代码行数超过100，方法或属性超过10  就要进行拆分
 */

 export {}
// 拆的过细就有可能降低内聚性 
class Product {
    public name:string;
    public price:number;
    public category:Category;
    public updateName() {}
    public updatePrice(){}
    public updateCategory(){}
}
class Category {
    public name:string;
    public icon:string
}
```

#### 1.2 开放封闭原则

- Open Closed Principle
- 对扩展开放，对修改关闭
- 增加需求时，扩展新代码，而非修改已有代码
- **这是软件设计的终极目标**

例如：下面新增 superVip、superSuperVip角色，我们值需要新new一个实例出来即可，不用在去改类中的老代码

```typescript
/**
 * 开放封装原则 对修改关闭 对扩展开发
 */

class Customer {
    constructor(public rank: string,public discount:number = 1 ) {

    }
}

class Product {
    constructor(public name: string, public price: number) {

    }
    //  以不同的顾客有不同等级 普通会员 VIP会员 普通股顾客 ，不同的等级打折不一样
    cost(customer:Customer) {
        return this.price * customer.discount
    }
}

let product = new Product('笔记本电脑',10000);
let member = new Customer('member',.8);
let vip = new Customer('vip',.6);
let guest = new Customer('guest');
// 新增客户登记
let superVip = new Customer('superVip',.4)
let superSuperVip = new Customer('superSuperVip',.1)

console.log(product.cost(member))
console.log(product.cost(vip))
console.log(product.cost(guest))
console.log(product.cost(superVip))
console.log(product.cost(superSuperVip))
```

#### 1.3 里氏替换原则

- Liskov Substitution Principle
- 子类能覆盖父类
- 父类能出现的地方子类就能出现
- JS使用比较少，可用ts描述

例如：下面的`Customer`类中的`drink`方法内的参数可以是父类`AbstractDrink`也可是其子类

```typescript
/**
 * 里氏替换原则
 * 任何在能使用父类的地方都要可以要使用子类
 */

 export {}

 class AbstractDrink {
     getPrice():any {
         return 1
     }
  }

  class CocaCola extends AbstractDrink {
      getPrice():any {
        //   违反了里氏代换原则 应该是返回价格
          return '我的一瓶CocaCola'
      }
  }

  class Sprite extends AbstractDrink {
    getPrice():any {
        return 2
    }
}
class Fanta extends AbstractDrink {
    getPrice(): any {
        return 5;
    }
}

class Customer {
    drink(abstractDrink: AbstractDrink) {
        console.log("花费" + abstractDrink.getPrice());
    }
}

// 里氏代换：可以替换，任何可以传父类的地方，都可以把子类传进去
// 里氏代换是一个原则，要求子类不能违反父类的功能和规定

let c1  =new Customer();
c1.drink(new AbstractDrink())
c1.drink(new CocaCola())
c1.drink(new Sprite())
```

#### 1.4 接口隔离原则

- Interface Segregation Principle
- 保持接口的单一独立，避免出现胖接口
- JS中没有接口，使用较少，用ts模拟
- 类似于单一职责原则，更关注接口

例如下面的：`Automobile`类实现了`flying`、`runing`、`swimming`，`car`实现了`runing`，可看出将接口单一出来容于复用

```typescript
/**
 * 接口隔离性原则
 * Interface Segregation Principle
    保持接口的单一独立，避免出现胖接口
    JS中没有接口，使用较少
    类似于单一职责原则，更关注接口
 * 
 */

 interface Runing{
     run():void
 }
 interface Flying {
     fly():void 
 }
 interface Swimming {
     swim():void
 }

class Automobile implements Runing,Flying,Swimming {
    run(){}
    fly(){}
    swim(){}
}

class Car implements Runing{
    run(){

    }
}

export {}
```

#### 1.5 依赖倒置原则

- Dependence Inversion Principle
- 面向接口编程，依赖于抽象而不依赖于具体实现
- 使用方只关注接口而不关注具体类的实现
- JS中使用较少（没有接口，弱类型）

例如：下面的`LinChiling`、`HanMeimei`实现了`Girlfriend`的接口，易于复用

```typescript
/**
 * 依赖倒置原则
 * 依赖抽象，而非依赖依赖具体的实现
 */

 interface Girlfriend {
     age:number;
     height:number;
     cook():void;
 }

 class LinChiling implements Girlfriend {
     age:number = 22;
     height:number = 178
     cook() {
         console.log('泡面')
     }
 }

 class HanMeimei implements Girlfriend {
     age:number = 35;
     height :number = 178;
     cook() {
         console.log('泡面')
     }
 }

 class SingleDog {
     constructor(public girlfriend:Girlfriend) {}
 }

 let dog1 = new SingleDog(new LinChiling());
 let dog2 = new SingleDog(new HanMeimei());

 console.log(dog1.girlfriend.age)
 console.log(dog2.girlfriend.age)
```

#### 1.6 迪米特法则

* 有时候也交最少知识原则
* 一个软件实体应当尽可能少地与其他实体发生相互作用
* 迪米特法则的初衷在于降低类之间的耦合
* 类定义尽可能实现内聚，少使用public修饰符，尽量使用`private`、`protected`等

例如：下面的 `CEO`值管`SaleManager`(销售经理)而不管`Saleman`销售者的关系。

```js
/**
 *迪米特法则
  有时候也叫做最少知识原则
  一个软件实体应当尽可能少地与其他实体发生相互作用
  迪米特法则的初衷在于降低类之间的耦合
  类定义时尽量实现内聚，少使用public修饰符 尽量使用 private protected 等
 */

 class Saleman {
     constructor(public name:string) {

     }
     sale() {
         console.log(this.name +'销售中....')
     }
 }

 class SaleManager {
     private salesman:Array<Saleman> = [new Saleman('张三'),new Saleman('李四')];
     sale() {
         this.salesman.forEach(salesman => salesman.sale())
     }
 }
 
 class CEO {
     private salesManager:SaleManager = new SaleManager();
     sale() {
         this.salesManager.sale();
     }
 }

 let ceo = new CEO();
 ceo.sale()
```

#### 1.7 合成复用原则

* 类的关系，类之间有三种基本关系，分别是 关联(聚合和组合)、泛化和依赖
* 如果一个类单向依赖另一个类，那么它们之间就是单向关联，如果彼此依赖则为相互依赖，即双向关联
* 关联关系包含两个特例：聚合和组合
  * 聚合：用来表示整体与部分的关系或者拥有关系，代表部分的对象可能会被整体拥有，但并不一定会随着整体的消亡而销毁，比如班级和学生
  * 合成或者说组合要比聚合关系强的多，部分和整体的生命周期是一致的，比如人和器官之间

例如：下面你的`Category`和`Product`是相互关联关系，`Student`内的`read`方法中使用了`book | pen`，是依赖的关系

```typescript
 export {}

 class Category {
    //  也是关联 双向关联 互相关联
     public products:Array<Product>
 }

 class Product {
    //  产品类有一个实例属性是分类，那么久认为产品关联了分类
    // 单向关联和双向关联
    public category:Category
 }

 class Class {
     public students:Array<Student>
 }

 class Book {

 }

 class Pen {

 }

 class Student {
    //  如果另外一个类是当前类的方法和属性或者 是局部变量就是依赖关系
     read(book:Book) {
         let pen = new Pen()
     }
 }
```

#### 1.8 总结：

* 开放性原则是核心，对修改关闭对扩展开放是软件设计的基石
* 单一职责要求我们设计接口和模块功能的时候尽量保证单一性和原子性，修改一条不影响全局和其他模块
* 里氏替换原则和依赖倒置原则要求面向接口和抽象编程，不要依赖具体实现，否则实现一改，上层调用者就要对应修改

#### 1.9 如何写出好代码？

* 可维护性 BUG 是否好改？
* 可读性 是否容易看懂？
* 可扩展性 是否可以添加新功能？
* 灵活性 添加新功能是否容易？老方法和接口是否容易复用？
* 简洁性 代码是否简单清晰？
* 可复用性 相同的代码不要写2遍？
* 可测试性 是否方便写单元测试和集成测试？