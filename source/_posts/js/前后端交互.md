---
title: 前后端交互
date: 2020-08-14 21:12:34
categories: JS
top: false
summary: 前后端交互
tags: 
 - JS
---

### 前后端交互

前后端交互主要涉及的是`Ajax`的使用，ajax是用来解决我们传统请求服务器是以跳转(刷新)页面的形式，这种用户体验效果不好，由此出现可以实现无刷新请求服务器数据的`Ajax`技术

### 一、原生Ajax

####1.1基本使用:

* 创建`XMLHttpRequest`对象

```js
let xhr = new XMLHttpRequest();
```

* 建立连接

```js
xhr.open('get','/请求路径',true) // true为异步(默认),false为同步
```

* 接收返回值，可以使用`onload`或`onreadystatechange`监听服务端返回的响应，当然`onload`可以理解与`onreadystatechange`中的`xhr.readyState==4`与`xhr.status==200`相同，推荐使用`onload`监听

```js
xhr.onload = function() {
    let res = JSON.parse(xhr,responseText)
    }
// 也可以
xhr.onreadystatechange = function() {
    console.log(xhr.readyState)
    console.log(xhr.status)
}
```

* 发送服务器，**这是最关键的一步，可以将上面的3步理解为ajax的配置，这步才是真正请求服务端**

```js
xhr.send()
```

#### 1.2 ajax详细分解

我们使用ajax主要使用`get`和`post`两个数据传输形式，而他们都要些特殊配置点

* get：get通过 url 传参，形式为queryString，例如:`/xx?username=zs&age=20`

* post：post通过http的请求体（正文）传参，有多种数据形式进行选择，默认是`application/x-www-form-urlencoded`，**客户端传给服务端的数据要是字符串形式**,例如：`xhr.setRequestHeader('Content-Type','application/json') `的要将数据进行`JSON.stringify(obj)`

  设置请求头数据格式：

  ```js
  xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded") // 默认编码
  xhr.setRequsetHeader("Content-Type","multipart/form-data") // 二进制格式
  xhr.setRequestHeader('Content-Type','application/json') // json编码
  ```

* 获取返还数据

  * 服务器返回json或者字符串数据

  ```js
  xhr.responseText // 来获取
  ```

  * 服务器返回xml数据

  ```js
  xhr.responseXML // 来获取
  ```

  在还xml数据的时候，服务器要设置响应头的`content-type`信息，例如在`koa`设置

  ```js
  ctx.set('content-type', 'text/xmls')
  // 例如
  router.get('/xml', async ctx => {
      ctx.set('content-type', 'text/xml')
      ctx.body = `<?xml version='1.0' encoding='utf-8' ?>
                  <book>
                      <nodejs>
                          <name>nodeJS实战</name>
                          <price>56元</price>
                      </nodejs>
                      <react>
                          <name>react入门</name>
                          <price>50元</price>
                      </react>
                  </book> `
  })
  ```

  当然我们也可以在客户端代码上重写响应头的`content-type`信息

  ```js
  xhr.overrideMimeType("text/xml");
  ```

* 获取响应头部信息可以通过

| 方法                                               | 描述                 |
| -------------------------------------------------- | -------------------- |
| xhr.getAllRequestHeaders()                         | 返回所有的响应头信息 |
| xhr.getRespnseHeader('头信息键例如`content-type`') | 返回指定的响应头信息 |

#### 1.3 onreadystatechange

onreadystatechage：存有处理服务器响应的函数，每当 readyState 改变时，onreadystatechange函数就会被执行，readyState存在服务器响应的状态码分为

| 状态码 | 描述                                                       |
| ------ | ---------------------------------------------------------- |
| 0      | 请求未初始化(代理被创建，但尚未调用 open()方法)            |
| 1      | 服务器连接已建立（open方法已进被调用）                     |
| 2      | 请求已接收（send方法已进被调用，并且头部和状态已经可获得） |
| 3      | 请求处理中 （下载中，responseText 属性已经包含部分数据）   |
| 4      | 请求已完成，且响应已就绪（下载操作已完成）                 |

onreadystatechange现在不推荐使用，因为有些繁琐，onload方法简便很多，推荐使用

#### 1.4 实例：获取xml数据

服务器

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const koaBody = require('koa-body')
const fs = require('fs')
const userData = require('./data/users.json')

const app = new Koa()
const router = new Router()
app.use(koaBody({
    multipart: true
}))
app.use(static(__dirname + '/static'))

router.get('/xml', async ctx => {
    ctx.set('content-type', 'text/xml')
    ctx.body = `<?xml version='1.0' encoding='utf-8' ?>
                <book>
                    <nodejs>
                        <name>nodeJS实战</name>
                        <price>56元</price>
                    </nodejs>
                    <react>
                        <name>react入门</name>
                        <price>50元</price>
                    </react>
                </book>
    `
})
app.use(router.routes())
app.listen(3000, () => {
    console.log('服务器开启....')
})
```

客户端：

```html
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
    </head>

    <body>
        <button>点击我获取xml</button>
    </body>
    <script>
        document.querySelector('button').onclick = function() {
            let xhr = new XMLHttpRequest()
            // xhr.overrideMimeType("text/xml");
            xhr.open('get', '/xml', true)
            xhr.onload = function() {
                let name = xhr.responseXML.getElementsByTagName("name")[1].innerHTML;
            }
            xhr.send()
        }
    </script>

</html>
```

### 二、上传文件资源

上传文件资源我们主要通过`Ajax`和`formData`对象互相配合实现，fromData 包裹上传的内容都会在`        <input type="file" class="myfile" id="">`对象中的`files`数组中

#### 2.1 FormData对象使用

* 创建与添加属性和值，它有个特点就是我们在客户端打印不到我们加入的信息，它只呈现有个空对象`{}`

```js
let form = new FormData()
form.append('name', 'zs')
console.log(form) // {}
```

* 与ajax结合实例

客户端：

```html
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
    </head>

    <body>
        <input type="file" class="myfile" id="">
        <button>点击上传</button>
    </body>
    <script>
        document.querySelector('button').onclick = function() {
            let file = document.querySelector('.myfile').files[0]
            let form = new FormData()
            form.append("img", file)
            form.append('name', 'zs')
            let xhr = new XMLHttpRequest()
            xhr.open('post', '/upload', true)
            xhr.onload = function() {
                console.log(xhr.responseText)
            }
            xhr.send(form)
        }
    </script>

</html>
```

服务端:

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const koaBody = require('koa-body')
const fs = require('fs')
const userData = require('./data/users.json')

const app = new Koa()
const router = new Router()
app.use(koaBody({
    multipart: true
}))
app.use(static(__dirname + '/static'))

router.post('/upload', async ctx => {
    console.log(ctx.request.body) 
    console.log(ctx.request.files)
        // ctx.body = "接受成功"
    let fileData = fs.readFileSync(ctx.request.files.img.path)
    fs.writeFileSync("static/imgs/" + ctx.request.files.img.name, fileData)
    ctx.body = "文件上传成功"
})

app.use(router.routes())
app.listen(3000, () => {
    console.log('服务器开启....')
})
```

#### 2.2 使用ajax监听上传进度

监听文件上传进度，我们要知道 文件当前上传了多大，文件总共多大等值，才能计算出到对应的上传进度和传输速度，而这些我们可以通过控制`xhr.upload`对象下的事件完成。xhr.upload对象下的常用事件有这些:

| 事件名          | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| onloadstart()   | 监听开始上传                                                 |
| onprogress(evt) | 监听数据传输，会被多次调用，它的`evt.total`：需要传输文件的总大小,`evt.loaded`：当前已上传的文件大小 |
| onabort()       | 监听文件是否被终止上传。文件终止上传可以调用` xhr.abort() `  |
| onerror()       | 监听文件是否上传失败                                         |
| onload          | 监听文件上传成功                                             |
| onloadend       | 不论问价成功或失败都会被调用                                 |

上面所说的传输位置是指传输到`formData`对象中，而不是直接往服务器传输，只有先将文件用formdata对象进行包裹完成我们才能进行传输，最后通过`xhr.send()`往服务器进行传输

实例：

服务端：

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const koaBody = require('koa-body')
const fs = require('fs')
const userData = require('./data/users.json')

const app = new Koa()
const router = new Router()
app.use(koaBody({
    multipart: true
}))
app.use(static(__dirname + '/static'))

router.post('/fileUpload', async ctx => {
    console.log(ctx.request.files)
    let fileData = fs.readFileSync(ctx.request.files.myfile.path)
    fs.writeFileSync("static/imgs/" + ctx.request.files.myfile.name, fileData)
    ctx.body = "文件上传成功"
})

app.use(router.routes())
app.listen(3000, () => {
    console.log('服务器开启....')
})
```

客户端

```html
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
    </head>

    <body>
        <input type="file" class="myfile"> 进度： <progress value="0" max="100"></progress>
        <span class="percent">0%</span>
        <span class="speed">20b/s</span>
        <button>点击上传</button>
        <button>取消上传</button>
    </body>

    <script>
        let xhr = new XMLHttpRequest()
        let btns = document.querySelectorAll("button")
        let stime
        let sloaded
        btns[0].onclick = function() {
            let file = document.querySelector('.myfile').files[0]
            let form = new FormData()
            form.append('myfile', file)
            xhr.open('post', '/fileUpload', true)
            xhr.onload = function() {
                console.log(xhr.responseText)
            }

            xhr.upload.onloadstart = function() {
                console.log('开始上传')
                stime = new Date().getTime()
                sloaded = 0
            }
            xhr.upload.onprogress = function(evt) {
                console.log('上传中...')
                let endTime = new Date().getTime()
                // 时间差
                let dTime = (endTime - stime) / 1000
                let dloaded = evt.loaded - sloaded
                let speed = dloaded / dTime
                let unit = 'b/s'
                stime = new Date().getTime()
                sloaded = evt.loaded
                if (speed / 1024 > 1) {
                    unit = "kb/s"
                    speed = speed / 1024
                }
                if (speed / 1024 > 1) {
                    unit = "mb/s"
                    speed = speed / 1024
                }
                console.log(speed)
                document.querySelector('.speed').innerHTML = speed.toFixed(2) + unit
                let percent = (evt.loaded / evt.total * 100).toFixed(0)
                console.log(percent)
                document.querySelector('progress').value = percent
                document.querySelector('.percent').innerHTML = percent + '%'
            }
            xhr.upload.onload = function() {
                console.log('上传成功')
            }
            xhr.upload.onloadend = function() {
                console.log('上传完成')
            }
            xhr.upload.onabort = function() {
                console.log('取消上传')
            }
            xhr.send(form)
        }

        btns[1].onclick = function() {
            xhr.abort()
        }
    </script>

</html>
```

#### 2.3 将图片信息对象转为base64格式

```js
let fileReader = new FileReader()
// this.files 是图片信息对象，是用input标签属性为file中的files获取到的对象
fileReader.readAsDataURL(this.file)
// 监听是否转化完成，完成后从fileReader.result获取到
fileReader.onload = () => {
    console.log(fileReader.result)
}
```
### 三、解决跨域问题

我们浏览器出于用户数据安全考虑，采用同源策略(相同的协议，域名，端口的请求方式才能调用同源的接口并获取到数据，否则不允许获取到接口数据，**值得注意的是这里调用接口请求是成功的，但数据会被浏览器拦截，我们接受不到**)。不能跨域是我们浏览器的自身行为，ajax也不能解决这个问题，世面上多采用`jsonp`、`CORS`、`后端代理`来解决浏览器不能跨域问题

#### 3.1 JSONP 

我们长期写html页面结构会发现`img`、`script`标签请求不同域的资源不受浏览器限制，而我们的JSONP技术正是采用`script`标签不受浏览器同源策略的影响，解决不能跨域问题。具体步骤：

* 前端先往`script的src`属性传入定义好的需要调用函数的函数名，例如`<script src="http://localhost:4000?callbcak=fn" ></script>`
* 后端接受到这个函数名，以字符串的形式进行调用，并将处理好的数据作为参数进行传递，返回页面

实例：我们设置两个服务器，http3000,http4000

http3000.js:

http3000服务器只是展示页面，它的页面还是放在静态文件下(static文件下)

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const app = new Koa()
const router = new Router()
app.use(static(__dirname + '/static'))

app.use(router.routes())
app.listen(3000, () => {
    console.log('3000端口服务开启...')
})
```

http3000(static文件夹下的展示文件)：

```html
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
    </head>

    <body>
        <button>点击获取跨域资源</button>
    </body>
    <script>
        function cbfn(res) {
            console.log(res) // 输出： {name:'zs',age:20}
        }
        let btn = document.querySelector('button')
        btn.onclick = function() {
            let o = document.createElement('script')
            // 传入函数名
            o.src = "http://localhost:4000/getAjax?cb=cbfn"
            document.querySelector('head').appendChild(o)
        }
    </script>
</html>
```

http4000.js : 接受到传入的函数名进行参数传入和调用

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const app = new Koa()
const router = new Router()
app.use(static(__dirname + '/static'))
router.get('/', async ctx => {
    ctx.body = '4000端口首页'
})
router.get('/getAjax', async ctx => {
    let cb = ctx.query.cb
    let obj = {
        name: 'zs',
        age: 20
    }
    ctx.body = `${cb}(${JSON.stringify(obj)})`
})

app.use(router.routes())
app.listen(4000, () => {
    console.log('4000端口服务开启...')
})
```

由上面可以知道，我们可以动态创建script标签并利用解决跨域请求问题，那么我们就可以将ajax进行封装，让它既可以发送普通请求，也可以发送 JSONP 请求，封装结果:

```js
function Ajax(options) {
    let opts = Object.assign({
        method: 'get',
        url: '',
        headers: {
            'content-type': 'application/x-www-form-urlencoded'
        },
        jsonp: 'cb',
        data: '',
        success: function() {}
    }, options)
    // 处理jsonp请求
    if (opts.dataType === 'jsonp') {
        jsonpFn(opts.url, opts.data, opts.jsonp, opts.success)
        return false
    }

    function jsonpFn(url, data, cbName, cbFn) {
        let fnName = 'lyz_' + Math.random().toString().substr(2)
        // 将方法传入到全局作用域去
        window[fnName] = cbFn
        let path = url + '?' + o2u(data) + '&' + cbName + '=' + fnName
        let o = document.createElement('script')
        o.src = path
        document.querySelector('head').appendChild(o)
    }

    // 普通ajax处理
    let xhr = new XMLHttpRequest()
    // get 请求
    if (opts.method == 'get') {
        let data = o2u(opts.data)
        opts.url = options.url + '?' + data
    }
    // 建立ajax连接
    xhr.open(opts.method, opts.url, true)
    for (let key in opts.headers) {
        xhr.setRequestHeader(key, opts.headers[key])
    }
    let sendData
    switch (opts.headers['cotent-type']) {
        case 'application/x-www-form-urlencoded':
            sendData = o2u(opts.data)
            break;
        case 'application/json':
            sendData = JSON.stringify(opts.data)
            break;
    }
    xhr.onload = function() {
        let resData;
        if (xhr.getResponseHeader('content-type').includes('xml')) {
            resData = xhr.responseXML
        } else {
            resData = xhr.responseText
        }
        opts.success(resData)
    }
    if (opts.method == 'get') {
        console.log(opts)
        console.log(opts.url)
        xhr.send()
    } else {
        xhr.send(sendData)
    }

    // 参数拼接
    function o2u(obj) {
        let keys = Object.keys(obj)
        let values = Object.values(obj)
        return keys.map((v, k) => {
            return `${v}=${values[k]}`
        }).join('&')
    }
}

// 不同域间调用获取数据
Ajax({
    url: 'http://localhost:4000/jsonp',
    data: {
        name: 'zs'
    },
    // 标注是 jsonp请求
    dataType: 'jsonp',
    // 后端需要调用函数名
    jsonp: 'callback',
    success: function(res) {
        console.log(res)
    }
})
```

#### 3.2 CORS 

CORS(Cross-orifin resource sharing)，跨域资源共享，是一份浏览器技术规范，用来避开浏览器的同源策略，它比 JSONP 更加方便，但它需要后端设置较多的参数（主要在响应头设置），并且前端也要进行配合。（在下面的  res.header()  在 koa 中换成  ctx.set() ，下面说的后端设置都在`http4000`服务器下，前端设置都在`http3000`服务器下）

1. 设置允许跨域请求

```js
//这个表示任意域名都可以访问。但缺点:1.不安全 2.不能传递用户凭证
res.header('Access-Control-Allow-Origin', '*'); 
//这样写，只有www.baidu.com 可以访问。(推荐使用)
res.header('Access-Control-Allow-Origin', 'http://www.baidu.com'); 
```

2. 设置允许客户端请求时携带凭证.
  非同源间进行请求是不允许携带凭证的，但我们可以设置，需要客户端和服务器进行配合设置。但如果第一步设置了 访问源为`*`，则即使设置了允许携带参数也会**报错**，这就是不推荐设置`*`的一个重要原因

后端设置：

```js
res.header('Access-Control-Allow-Credentials', true)
```

前端设置：

```js
xhr.withCredentials = true
```

3. 设置允许客户端获取的响应头部信息(key)

   CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`.如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定
```js
res.header('Access-Control-Expose-Headers'，'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); // 不止这些
```

4. 设置允许前端请求的方法 

```js
res.header("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,HEAD,OPTIONS");
```

5. 设置允许前端设置请求头部信息

   在允许前端设置请求头部信息后会出现`预检请求(options请求)`，下面会详细分析这个预检请求是个啥？

后端:允许前端设置请求头信息

```js
res.header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Authorization,test"); // 将要设置的请求头key放到这里面,例如:test
```

客户端：

```js
xhr.setRequestHeader('test', "somevalue") // 这样在请求头上可以看见 tset: somevalue的键值对
```

后端设置：多添加一个options 请求路由，处理预检请求(并且它需要包含我们非同源请求路由（/get路由）下的所有设置参数,主要是允许跨域和允许上传凭证两个配置)

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const app = new Koa()
const router = new Router()

router.options('/:all', async ctx => {
    ctx.set("Access-Control-Allow-Origin", "http://localhost:3000")
    // 3.由于非同源是不支持将凭证带上来的,我们得配置
    ctx.set('Access-Control-Allow-Credentials', true)
    // 4.允许获取的头部信息
    ctx.set("Access-Control-Expose-Headers", "Date,Content-Type, Content-Length")
    // 5. 设置前端允许请求的方法
    ctx.set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,HEAD,OPTIONS");
    // 6.允许前端设置的头部
    ctx.set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Authorization,test");
    // 7.设置预检请求的缓存时间；
    ctx.set("Access-Control-Max-Age", 3600);
    console.log('有预检请求进来')
    ctx.body = ""
})
router.get('/get', async ctx => {
    // 1.允许所有的域名请求这个地址，但它并不安全，并且不能携带cookie凭证到我们的服务端来
    // ctx.set("Access-Control-Allow-Origin", "*");
    // 2. 限制范围设置访问域名
    ctx.set("Access-Control-Allow-Origin", "http://localhost:3000")
    // 3.由于非同源是不支持将凭证带上来的,我们得配置
    ctx.set('Access-Control-Allow-Credentials', true)
    // 4.允许获取的头部信息
    ctx.set("Access-Control-Expose-Headers", "Date,Content-Type, Content-Length")
    // 5. 设置前端允许请求的方法
    ctx.set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,HEAD,OPTIONS");
    ctx.body = '4000端口返回的数据'
})

app.use(router.routes())
app.listen(4000, () => {
    console.log('4000服务器开启....')
})
```

预检请求出现几种情况

* 发送 PUT DELETE CONNECT OPTIONS TRACE PATCH 请求都会出现
* 设置`Accept`、`Accept-Language`、`Content-Type`、`DPR`、`Downlink`、`Save-Data`、`viewport-Width`、`Width`请求头之外的键值会出现
* 设置`Content-Type`的值不属于`application/x-wwww-form-urlencoded`、`multipart/form-data`、`text/plain`会出现

设置预检请求的有效期，单位为秒，在此期间不用发送另一条预检请求

```js
res.header("Access-Control-Max-Age", 3600);
```

CORS实例：

http4000服务端配置

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const app = new Koa()
const router = new Router()

router.options('/:all', async ctx => {
    ctx.set("Access-Control-Allow-Origin", "http://localhost:3000")
    // 3.由于非同源是不支持将凭证带上来的,我们得配置
    ctx.set('Access-Control-Allow-Credentials', true)
    // 4.允许获取的头部信息
    ctx.set("Access-Control-Expose-Headers", "Date,Content-Type, Content-Length")
    // 5. 设置前端允许请求的方法
    ctx.set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,HEAD,OPTIONS");
    // 6.允许前端设置的头部
    ctx.set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Authorization,test");
    // 7.设置预检请求的缓存时间；
    ctx.set("Access-Control-Max-Age", 3600);
    console.log('有预检请求进来')
    ctx.body = ""
})

router.get('/get', async ctx => {
    // 1.允许所有的域名请求这个地址，但它并不安全，并且不能携带cookie凭证到我们的服务端来
    // ctx.set("Access-Control-Allow-Origin", "*");
    // 2. 限制范围设置访问域名
    ctx.set("Access-Control-Allow-Origin", "http://localhost:3000")
    // 3.由于非同源是不支持将凭证带上来的,我们得配置
    ctx.set('Access-Control-Allow-Credentials', true)
    // 4.允许获取的头部信息
    ctx.set("Access-Control-Expose-Headers", "Date,Content-Type, Content-Length")
    // 5. 设置前端允许请求的方法
    ctx.set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,HEAD,OPTIONS");
    ctx.body = '4000端口返回的数据'
})

app.use(router.routes())
app.listen(4000, () => {
    console.log('4000服务器开启....')
})
```

http3000客户端

```html
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
    </head>

    <body>
        <button>点击发送非跨域请求</button>
        <button>点击发送跨域请求</button>
        <button>点击设置cookie</button>
    </body>

    <script>
        let btns = document.querySelectorAll('button')
        btns[0].onclick = async function() {
            console.log('点击发送非跨域请求')
            let xhr = new XMLHttpRequest()
            xhr.open('get', '/get', true)
            xhr.setRequestHeader('content-type', 'application/json')
            xhr.onload = function() {
                console.log(xhr.getAllResponseHeaders('content-type'))
                console.log(xhr.responseText)
            }
            xhr.send()
        }
        btns[1].onclick = async function() {
            console.log('点击发送跨域请求')
            let btn2Result = await ajax('get', 'http://localhost:4000/get')
            console.log(btn2Result)
        }
        btns[2].onclick = async function() {
            let btn3Result = await ajax('get', '/setCookie')
            console.log(btn3Result)
        }

        function ajax(method, url) {
            return new Promise((resolve, reject) => {
                let xhr = new XMLHttpRequest()
                xhr.open(method, url, true)
                // 允许跨域携带凭证
                xhr.withCredentials = true
                // 设置请求头
                xhr.setRequestHeader('test', "somevalue")
                xhr.onload = function() {
                    console.log(xhr.getAllResponseHeaders())
                    return resolve(xhr.responseText)
                }
                xhr.send()
            })
        }
    </script>

</html>
```

#### 3.3 后端代理

跨域是浏览器规范，但我们可以借助服务器来避开浏览器限制，利用同服务器进行转发到另一个服务器去获取数据在将返回的数据传给同个服务器的请求。在node中我们使用`http`模块的`request`方法进行转发，也可以使用`koa-server-http-proxy`模块包实现代理转发，这里直接上实例:

koa-server-http-proxy 中间件实现代理：

安装:

```bash
npm i koa-server-http-proxy -S
```

配置：

```js
app.use(koaServerHttpProxy('/api', {
    target: 'http://localhost:4000', // 转发的目标源
    pathRewrite: { '^/api': '' }, // 将api强调
    changeOrigin: true
}))
```

实例：

5000服务器设置：

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const koaServerHttpProxy = require('koa-server-http-proxy')

const app = new Koa()
const router = new Router()
app.use(static(__dirname + '/static'))
app.use(koaServerHttpProxy('/api', {
    target: 'http://localhost:4000',
    pathRewrite: { '^/api': '' },
    changeOrigin: true
}))
router.get('/get', async ctx => {
    ctx.body = 'hello 5000'
})
router.get('/proxy', async ctx => {
    ctx.body = '5000端口的proxy'
})
app.use(router.routes())

app.listen(5000, () => {
    console.log('5000服务器开启...')
})
```

5000服务器页面:

```html
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
    </head>

    <body>
        <h1>5000端口</h1>
        <button>点击发送</button>
    </body>
    <script>
        document.querySelector('button').onclick = function() {
            let xhr = new XMLHttpRequest()
            xhr.open('get', '/api/proxy', true)
            xhr.onload = function() {
                console.log(xhr.responseText) // 输出4000端口的proxy
            }
            xhr.send()
        }
    </script>
</html>
```

4000服务器设置:

```js
const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const app = new Koa()
const router = new Router()

router.get('/proxy', async ctx => {
    ctx.body = '4000端口的proxy'
})

app.use(router.routes())
app.listen(4000, () => {
    console.log('4000服务器开启....')
})
```



