---
title: 小程序开发基础篇
date: 2020-07-02 19:05:58
categories: 小程序
top: true
summary: 小程序开发基础篇
tags: 
 - 小程序
---

## 小程序开发基础篇

## 一、小程序构建后的目录结构

```js
├── pages ······································ 【目录】存放所有的小程序页面
│   │── index ···································· 【目录】index 页面
│   │   ├── index.wxml ······························· 【文件】 index 页面的结构
│   │   ├── index.js ································· 【文件】 index 页面的逻辑
│   │   ├── index.json ······························· 【文件】 index 页面的配置
│   │   └── index.wxss ······························· 【文件】 index 页面的样式
│   └── logs ····································· 【目录】 logs 页面
│       ├── logs.wxml ································ 【文件】 logs 页面的结构
│       └── logs.js ·································· 【文件】 logs 页面的逻辑
└── utils ······································ 【目录】 存放小程序中用到的工具函数
├── app.js ····································· 【文件】 小程序逻辑
├── app.json ··································· 【文件】 小程序的公共配置
├── app.wxss ··································· 【文件】小程序公共样式表
├── project.config.json ························ 【文件】 开发工具配置文件
```

说明：

* `app.js`是小程序的入口文件，运行小程序，第一个被运行的就是`app.js`
* `app.json`是小程序的全局配置文件，对小程序每个页面生效
* `app.wxss`是小程序的全局样式文件，对小程序每个页面生效
* `index.json`是小程序的页面配置，只对该页面的`window`配置才有效 

注意：

* 对于小程序运行而言，`app.js`和`app.json`是必不可少的
* 对于小程序页面而言，`xxx.js`和`xxx.wxml`是必不可少的

## 二、 页面结构

### 2.1 小程序页面和Vue组件对比

* 每个 `.vue`文件是由`template`模板结构，`script`行为逻辑，`style`样式三部分组成的
* 每个小程序页面，是由`.wxml`结构、`.js`逻辑文件、`.json`配置文件、`.wxss`样式表这四部分组成的

![微信公众平台的账号分类](/medias/imges/xcx/product/img1.png)

小程序页面中每个文件的作用

* `.wxml`:用来描述当前这个页面的标签结构，同时提供了类似于`vue`中指令的语法
* `.js`：用来定义当前页面中用到的数据、交互逻辑和响应用户的操作
* `.json`：用来定义单曲页面的个性化配置，例如，为每个单独配置顶部演示，是否允许下拉刷新等，**说白了就是配置`app.json`中的window节点**，用来个性化页面窗口配置
* `.wxss`：用来定义样式来梅花当前的页面

### 2.2 让小程序页面为首页

- 打开 `app.json` 全局配置文件，找到 `pages` 节点。这个 pages 节点是一个数组，存储了项目中所有页面的访问路径。其中，`pages` 数组中第一个页面路径，就是小程序项目的默认首页。
- 所以只需要修改 pages 数组中路径的顺序，就可以可修改小程序的默认首页。

## 三、小程序基础组件

> 小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼接称自己的小程序，小程序中的组件，就像 HTML 中的 div 、p、span 等标签的作用一样，用于搭建页面的基础结构

### 3.1 text文本组件的用法

> text组件类似有`HTML中的span`元素

| 属性       | 类型    | 默认值 | 必填 | 描述                                                         |
| :--------- | :------ | :----- | :--- | :----------------------------------------------------------- |
| selectable | boolean | false  | 否   | 文本是否可选                                                 |
| space      | string  | ---    | 否   | 显示连续空格，可选参数：`ensp`(英文字符大小)、`emsp`(中文字符大小)、`nbsp`(按照字符实际大小) |
| decode     | boolean | false  | 否   | 是否解码                                                     |

**注意：**

* `text`组件相当于**行内标签**，在同一行显示
* 除了文本节点以外的其他节点都无法长按选中
* [text 文档](https://developers.weixin.qq.com/miniprogram/dev/component/text.html)

**代码演示：**

```html
<view>
    <!-- 长按文本是否可选 -->
    <text selectable='true'>web</text>
</view>

<view>
    <!-- 显示连续空格的方式 -->
    <view>
        <text space='ensp'>H  a  c  k</text>
    </view>
    <view>
        <text space='emsp'>H  a  c  k</text>
    </view>
    <view>
        <text space='nbsp'>H  a  c  k</text>
    </view>
</view>

<view>
    <text>skyblue</text>
</view>

<view>
    <!-- 是否解码 -->
    <text decode='true'>&nbsp; &lt; &gt; &amp; &apos; &ensp; &emsp;</text>
</view>
```

### 3.2 view视图容器组件的用法

> view 视图容器，类似于`HTML中的div`

| 属性                   | 类型    | 默认值 | 必填 | 描述                                                         |
| ---------------------- | ------- | ------ | ---- | ------------------------------------------------------------ |
| hover-class            | string  | none   | 否   | 指定按下去的样式类。当`hover-class="none"`时，没有点击态效果 |
| hover-stop-propagation | boolean | false  | 否   | 指定是否阻止本节点的祖先系欸但出现点击态                     |
| hover-start-time       | number  | 50     | 否   | 按住够多久出现点击态，单位毫秒                               |
| hover-stay-time        | number  | 400    | 否   | 手值松开后点击态保留时间，单位毫秒                           |

[文档](https://developers.weixin.qq.com/miniprogram/dev/component/view.html)

**代码演示**

```html
<view hover-class='box1'>
    <view
          hover-stop-propagation='true'
          hover-class='box'
          hover-start-time='2000'
          hover-stay-time='3000'>
        box1
    </view>
</view>
```

### 3.3 button按钮组件的用法

| 属性名   | 类型    | 默认值  | 描述                        |
| -------- | ------- | ------- | --------------------------- |
| size     | String  | default | 按钮的大小                  |
| type     | String  | default | 按钮的样式类型              |
| plain    | Boolean | fasle   | 按钮是否镂空，背景色透明    |
| disabled | Boolean | false   | 是否禁用                    |
| loading  | Boolean | false   | 内容前面是否带 loading 图标 |

**注意：**

* button 组件默认独占一行，设置`size`为`mini`时可以一行显示多个
* [文档](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

**代码演示:**

```html
<button size='mini' type='primary'>前端</button>

<button size='mini' type='default' disabled='true'>前端</button>

<button size='mini' type='warn' loading='true'>前端</button>
```

### 3.4 input文本输入框组件的用法

| 属性名      | 类型    | 默认值 | 描述                                    |
| ----------- | ------- | ------ | --------------------------------------- |
| value       | String  | ---    | 输入框的初始内容                        |
| type        | String  | text   | input的类型                             |
| password    | Boolean | false  | 是否密码类型                            |
| placeholder | String  | ---    | 输入框为空时占位符                      |
| disabled    | Boolean | false  | 是否禁用                                |
| maxlength   | Number  | 140    | 最大输入长度，设置 `-1`时不限制最大长度 |

**注意：**

* [文档](https://developers.weixin.qq.com/miniprogram/dev/component/input.html)

**代码演示**

```html
<input placeholder='111' type='idcard' placeholder-style="color: skyblue" />
```

### 3.5 image图片组件的用法

| 属性名 | 描述                       |
| ------ | -------------------------- |
| src    | 支持本地和线上图片         |
| mode   | 指定图片的裁剪、缩放的模式 |

**注意：**

* image 组件默认的宽度是`300px`、高度是`225px`
* image组件中二维码/小程序码图片不支持长按识别
* [文档](https://developers.weixin.qq.com/miniprogram/dev/component/image.html)

**代码演示：**

```html
<image src='/assets/5.jpg' mode='aspectFit'></image>

<image src='https://wx.qlogo.cn/mmhead/Q3auHgzwzM7teJKyb7Oicw6x2rDiaD5BkDPFP2kccFO6a566TzzUyUgA/0' mode='widthFix'></image>
```

## 四、 wxss 中常用的样式选择器

> `wxss`是一套样式语言，用来决定`wxml`的组件应该怎么显示

### 4.1 初始`wxss`

* wxss 具有css 大部分特性
* wxss 对css 进行了扩充以及修改，以适应微信小程序的开发
* [文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)

### 4.2 wxss与css的区别

* 尺寸单位 （rpx）
* 样式导入 （import）

![wxss与css的区别](/medias/imges/xcx/product/img1.png)

### 4.3 什么是wxss

* 标签选择器
* id选择器
* class选择器
* 伪类选择器
* data-* 属性选择器
* :nth-of-type() 常用的css3选择器
* 其他

**代码演示：**

```html
<view id='v1'>111111</view>
<view class='v2'>111111</view>
<view>111111</view>
<view data-color="pink">111111</view>
<style>
    view {
        font-size: 12px;
    }

    #v1 {
        background-color: red;
    }

    .v2 {
        background-color: yellow;
    }

    .v2::before {
        content: '====';
    }

    view:nth-of-type(3) {
        background-color: blue;
    }

    [data-color="pink"] {
        background-color: pink;
    }
</style>
```

### 4.4 什么是`rpx`尺寸单位

> `rpx`是微信小程序独有的，**解决屏幕自适应的尺寸单位**

* 可以根据屏幕宽度进行自适应，不论屏幕大小，都规定屏幕宽为**750rpx**
* 通过`rpx`设置元素和字体的大小，小程序在**不同尺寸**的屏幕上，可以实现自动适配
* [文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)

**rpx和px之间的换算**

> 以`iPhone6`为例，`iPhone6`的屏幕宽度为`375px`,共有`750`个物理像素点，则`750rpx=375px=750物理像素点`，也就是 `1rpx=0.5px=1物理像素点`

|      设备      | `rpx` 换算 `px` (屏幕宽度/750) | `px` 换算 `rpx` (750/屏幕宽度) |
| :------------: | :----------------------------: | :----------------------------: |
|   `iPhone5`    |       `1rpx` = 0.42`px`        |       `1px` = `2.34rpx`        |
|   `iPhone6`    |        `1rpx` = `0.5px`        |         `1px` = `2rpx`         |
| `iPhone6 Plus` |       `1rpx` = `0.552px`       |       `1px` = `1.81rpx`        |

那么也就是说：如果在`iPhone6`上，如果要绘制宽`100px`，高`20px`的盒子，换算成`rpx`单位，宽高分别为 `200rpx` 和 `40rpx`

**注：[rpx 单位详细文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)**

**rpx和iPhone6设计稿的关系**

> 开发小程序时设计师可以用`iPhone6`作为视觉稿的标准

官方建议：

* 开发微信小程序时，设计师可以用`iPhone6`作为视觉稿的标准
* 如果要根据`iPhone6`的设计稿，绘制小程序页面，可以直接吧单位从`px`替换为`rpx`
* 例如：假设`iPhone6`设计稿上，要绘制一个宽搞为`200px`的何止，换算为`rpx`也是`200rpx`

### 4.5 `@import`样式导入

语法：

* 使用`@import`语句可以导入外联样式表
* 语法格式：`@import "wxss演示表文件的相对路径"`

```css
@import "/assets/common/common.wxss";
/* @import "../../assets/common/common.wxss"; */

.box {
    width: 375rpx;
    height: 375rpx;
    background-color: skyblue;
}
```

### 4.6 全局样式和局部样式

* 全局样式

> 定义在`app.wxss`中的样式为全局样式，作用于每一个界面

* 局部样式

> 在`page`的`wxss`文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖`app.wxss`相同的选择器

**注意:**当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式效果！

## 五、app.json 配置文件

> 小程序根目录下的`app.json`文件用来对微信小程序进行全局配置，它决定了页面文件的路径，窗口表现，设置网络超时时间，设置多 tab 等

在`app.json`配置文件中，最重要的配置节点是:

* pages 数组：配置小程序的页面路径
* window 对象：用来设置小程序的状态栏、导航条、标题、窗口背景色
* tabBar 对象：配置小程序的tab栏效果

[全局配置详细文档](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE)

### 5.1 page数组的用法

> `app.json`中的`page`数组，用来配置小程序的页面路径

基础配置：

* pages 用于指定小程序由那些页面组成，每一项都对应一个页面的 `路径+文件名`信息
* 文件名不需要写文件后缀，框架会自动去寻找对应位置的`.json`、`.js`、`.wxml`、和`.wxss`四个文件进行处理

注意：

* 数组的第一项代表小程序的初始页面(首页)
* 小程序中新增/减少页面，都需要对 `pages`数组进行修改，否则在运行小程序时就会报错

### 5.2 window节点的用法

> 每个小程序页面也可以使用`.json`文件对本页面的窗口表现进行配置，页面中配置项在当前页面会覆盖`app.json`的window中相同配置项，文件内容为一个`JSON`对象

![window节点](/medias/imges/xcx/product/img3.png) 

| 属性                      | 类型     | 默认值    | 描述                                                         |
| ------------------------- | -------- | --------- | ------------------------------------------------------------ |
| navigationBackgroundColor | HexColor | `#000000` | 导航栏背景颜色                                               |
| navigationBarTextStyle    | string   | white     | 导航栏标题颜色，仅支持`back/white`                           |
| navigationBarTitleText    | string   |           | 导航栏标题文字内容                                           |
| navigationStyle           | string   | default   | 导航栏样式，仅支持以下值:`default`默认样式，`custom`自定义导航栏，值保留右上角胶囊按钮 |
| backgroundColor           | HexColor | `#ffffff` | 窗口的背景色                                                 |
| backgroundTextStyle       | string   | dark      | 下来loading 的样式，仅支持 `dark/light`                      |
| backgroundColorTop        | string   | `#ffffff` | 顶部窗口的背景色，仅`ios`支持                                |
| backgroundColorBotton     | string   | `#ffffff` | 底部窗口的背景色，仅`ios`支持                                |
| enablePullDownRefresh     | boolean  | false     | 是否开启当页面下拉刷新                                       |
| enReahBottomDistance      | number   | 50        | 页面上拉触底事件触发时距离页面底部距离，单位为`px`           |
| pageOrientation           | string   | protrait  | 配置旋转设置，支持`auto/protrait/landscape`                  |
| disableScroll             | boolean  | false     | 设置为`true`则页面整体不能上下滚动，只在页面配置中有效，无法在`app.json`中配置 |
| usingComponents           | Object   | 否        | 页面自定义组件配置                                           |
| style                     | string   | default   | 启动新版的组件样式                                           |

**代码样式**

```json
{
    "navigationBarBackgroundColor": "#ffffff",
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "微信接口功能演示",
    "backgroundColor": "#eeeeee",
 	"backgroundTextStyle": "light"
}
```

[官网的属性配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)

### 5.3 tabBar 节点用法

> 如果小程序时应该多 tab 应用(客户端窗口的底部或顶部有 tab 栏可以切换页面)，可以通过 tabBar 配置项指定 tab 栏 的表现，以及 tab 切换时显示的队友页面

![tabBar节点](/medias/imges/xcx/product/img4.png) 

| 属性            | 类型     | 必填 | 默认值 | 描述                                                 |
| --------------- | -------- | ---- | ------ | ---------------------------------------------------- |
| color           | HexColor | 是   | ---    | tab 上的文字默认颜色，仅支持 十六进制颜色            |
| selectedColor   | HexColor | 是   | ---    | tab 上的文字选中时的颜色，仅支持十六进制颜色         |
| backgroundColor | HexColor | 是   | ---    | tab 的背景色，仅支持十六进制颜色                     |
| borderStyle     | string   | 否   | black  | tabbar 上边框的颜色，仅支持`black / white`           |
| list            | Array    | 是   | ---    | tab 的列表，详见 `list`属性说明，最少2个，最多5个tab |
| position        | string   | 否   | bottom | tabBar 的位置，仅支持`bottom / top`                  |
| custom          | boolean  | 否   | false  | 自定义 tabBar                                        |

**list属性**

> list 接受一个数组，只能配置最少2个，最多5个，tab按数组的顺序排序，每个项都是一个对象，其属性值如下：

| 属性             | 类型   | 必填 | 描述                                                         |
| ---------------- | ------ | ---- | ------------------------------------------------------------ |
| pagePatg         | string | 是   | 页面路径，必须在 pages 中先定义                              |
| text             | string | 是   | tab 上按钮文字                                               |
| iconPath         | string | 否   | 图片路径，icon大小限制为`40kb`,建议尺寸为`81px*81px`，不支持网络图片，当`position`为 top 时，不显示 icon |
| selectedIconPath | string | 否   | 选中时的图片路径，icon 大小限制为`40kb`,建议尺寸为`81px*81px`，不支持网络图片，当`position`为`top`时，不显示icon |

**注意：**

- **都不支持网络图片**
- **当 position 为 top 时，不显示 icon。**

###5.4 page.json 页面配置

> 每一个小程序页面也可以使用`.json`文件来对本页面的窗口表现进行配置，页面中配置项在当前页面会覆盖`app.json`的`window`中相同的配置项，文件内容为一个 JSON 对象，他配置属性和 `app.json`的 window节点配置信息是一样的

**页面配置和局部配置的关系：**

* `app.json` 中的`window`节点，可以全局配置小程序中每个页面的窗口表现
* 如果某些小程序页面，想要拥有特殊的窗口表现，此时页面级别的`.json`配置文件就库属性这种需求
* **页面级别配置优先于全局配置生效**
* [页面配置文档](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)

## 六、小程序生命周期

> 生命周期（Life Cycle）是指一个对象从 `创建->运行->销毁`的整个阶段，强调的是一个时间段

### 6.1 小程序的生命周期

* 小程序的启动，表示生命周期的开始
* 小程序的关闭，表示生命周期的结束
* 中间小程序运行过程，就是小程序的生命周期

### 6.2 小程序生命周期的两种类型

* 应用生命周期：特指小程序从启动 -> 运行 -> 销毁的过程
* 页面生命周期：特指小程序中，每个页面的加载-> 渲染 -> 销毁 的过程

**注意：页面的生命周期范围较小，应用程序的生命周期范围较大**

![微信公众平台的账号分类](/medias/imges/xcx/product/img5.png)

### 6.3 小程序的生命周期函数

> 小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行

生命周期函数的作用：允许程序员在特定的生命周期时间点上，执行某些特定的操作。例如：页面刚加载的时候，在生命周期函数中自动发起数据请求，获取当前页面的数据。

**注意：生命周期强调的是时间段，生命周期函数强调的是时间点。**

### 6.4 应用生命周期

* `app.json`是小程序执行的入口文件，在`app.js`中必须调用`App()`函数，且值能调用一次，其中，`App()`函数是用来注册并执行小程序的。
* `App(Object)`函数接收一个`Object`参数，可以通过这个`Object`参数，指定小程序的生命周期函数
* [应用生命周期文档](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)

应用生命周期函数执行顺序都是按下表次序从上往下执行的

| 方法名   | 类型     | 描述                                | 触发时机                                         |
| -------- | -------- | ----------------------------------- | ------------------------------------------------ |
| onLaunch | Function | 生命周期回调 - 监听小程序**初始化** | 小程序初始化完成时(全局只触发一次)               |
| onShow   | Function | 生命周期回调 - 监听小程序**显示**   | 小程序启动，或从后台进入前台显示时（可重复触发） |
| onHide   | Function | 生命周期回调 - 监听小程序**隐藏**   | 小程序从前台进入后台时（可重复触发）             |

**app.js代码**

```js
App({

    /**
   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
   */
    onLaunch: function () { },

    /**
   * 当小程序启动，或从后台进入前台显示，会触发 onShow
   */
    onShow: function (options) { },

    /**
   * 当小程序从前台进入后台，会触发 onHide
   */
    onHide: function () { },

    /**
   * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息
   */
    onError: function (msg) { }
})

```

### 6.5 页面生命周期函数

* 每个小程序页面，必须拥有自己的`.js`文件，且必须调用`Page()`函数，否则报错，其中`Page()`函数用来注册小程序页面
* `Page(Object)`函数接受一个`Object`参数，可以他通过这个`Object`参数，指定页面的生命周期函数

页面生命周期函数执行顺序都是按下表次序从上往下执行的

| 方法名   | 类型     | 描述                 | 触发时机                 |
| -------- | -------- | -------------------- | ------------------------ |
| onLoad   | Function | 监听页面加载         | 页面初始化时(只触发一次) |
| onShow   | Function | 监听页面显示         | 切换到后台(循环触发)     |
| onReady  | Function | 监听页面初次渲染完成 | 初次渲染完成(只触发一次) |
| onHide   | Function | 监听页面异常         | 后台切换到前台(循环触发) |
| onUnload | Function | 监听页面卸载         | 页面卸载(只触发一次)     |

**页面生命周期.js**

```js
//index.js
//获取应用实例
const app = getApp()

Page({

    /**
   * 页面的初始数据
   */
    data: { },

    /**
   * 生命周期函数--监听页面加载
   */
    onLoad: function (options) { },

    /**
   * 生命周期函数--监听页面初次渲染完成
   */
    onReady: function () { },

    /**
   * 生命周期函数--监听页面显示
   */
    onShow: function () { },

    /**
   * 生命周期函数--监听页面隐藏
   */
    onHide: function () { },

    /**
   * 生命周期函数--监听页面卸载
   */
    onUnload: function () { },

    /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
    onPullDownRefresh: function () { },

    /**
   * 页面上拉触底事件的处理函数
   */
    onReachBottom: function () { },

    /**
   * 用户点击右上角分享
   */
    onShareAppMessage: function () { }
})
```

## 七、小程序的视图与逻辑

### 7.1 数据绑定

* 定义数据
  * 小程序每个页面，是由 4 部分组成，其中`.js`文件内可以定义页面的数据、生命周期函数，其他业务逻辑
  * 如果要在`.js`文件内定义页面的数据，只需把数据定义在`data`节点下即可
* `Mustache`语法格式绑定数据

> 把`data`中的数据绑定在页面中渲染，使用`Mustache`语法(双大括号)将变量包裹起来即可

```html
<view>{{info}}</view>
```

**注意：Mustache语法主要场景**

* 绑定内容
* 绑定属性
* 运算(三元表达式、算术表达式、逻辑判断、字符串运算、数据路径运算)

**代码演示：**

```html
<!-- 页面结构 -->

<!-- 绑定内容和属性 -->
<view id="item-{{id}}">{{ info }}</view>

<!-- 算数运算 -->
<view>{{ 1 + 1 }}</view>

<!-- 三元表达式 -->
<view>{{ id == 10 ? "正确" : "错误" }}</view>
```

```js
// 页面数据

Page({
    data: {
        info: 'i miss you',
        id: 10,
        arr: [1, 2, 3]
    }
})
```

### 7.2 小程序中的事件

#### 7.2.1 `bindtap`绑定触摸事件

> 在小程序中，不存在网页中的`onclick`鼠标点击事件，而是通过`tap`事件来响应触摸行为

* 通过 bindtap，可以为组件绑定触摸事件，语法如下： 

```html
<view bindtap="tapName">Click me !</view>
```

* 在相应的 Page 定义中写上相应的事件处理函数，事件参数是event： 

```js
Page({
    tapName: function(event) {
        console.log(event)
    }
})
```

#### 7.2.2 `bindinput`绑定文本框输入事件

> 在小程序中，通过`input`事件来响应文本框的输入事件

普通文本事件绑定：

* 通过 bindinput ，可以为文本框绑定输入事件，语法如下：

```html
<input bindinput='iptHandler' value='{{info}}'></input>
```

* 在相应的 Page 定义中写上相应的事件处理函数，事件参数是`event`

```js
Page({
    inputName:function(event) {
        console.log(event)
    }
})
```

data和文本框之间的数据同步：

* 监听文本框的数据变化

> 在文本框的 input 事件处理函数中，通过事件参数 event ，能够访问到文本框的最新值
>
> 语法：**event.detail.value**

* 修改data中的数据

> 通过 `this.setData(dataObject)`方法，可以给页面中的 data 数据重新赋值，例如：监听文本框的数据变化，并把最新的值赋值给data 中的msg

```js
Page({
    data:{
        info:'213'
    },
    inputName:function(event) {
        this.setData({
            msg:event.detail.value // 为data 中的msg重新赋值
        })
    }
})
```

#### 7.2.3 事件传参

* 不能在绑定事件的同时传递参数

> 小程序中的事件传参比较特殊，不能在为组件绑定事件的同时，为事件处理函数传递参数

错误：下面的代码将不能正常工作，因为小程序会吧 `bindtap`后指定的值，统一当做事件名称来处理

```html
<button type="primary" bindtap="btnHandle(123)">事件传参</button>
```

* 通过 `data-*`自定义属性传参

如果要在组件触发事件处理函数的时候，传递参数，可以为组件提供`data-*`自定义属性传参

代码如下:其中，info会被当做参数名，数组123会被当做参数值

```html
<button bindtap="btnHandleer" data-info="{{123}}"></button>
```

* 获取`data-*`自定义属性中传递的参数

通过事件参数`event.target.dataset.参数名`，能够获取`data-*`自定义属性传递到事件处理函数中的参数，示例代码如下:

```js
btnHandler:function(event) {
    console.log(event.target.dataset.info)
}
```

#### 7.2.4 this.setData(dataObject)设置data 中的数据

> 在原生值不管是否是异步的，这个方法都能将请求回来的数据赋值到`data`节点对应的值中去

### 7.3 WXS脚本简介

#### 7.3.1 什么是wxs

> wxs 是小程序的一套脚本语言，结合`wxml`，可以构建出页面的结构

#### 7.3.2 wxs的注意事项

| 注意点                      | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| 没有兼容性                  | `wxs`不依赖于运行时的基本库版本，可以在所有的版本的小程序中运行 |
| 与`javascript`不同          | wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript一致 |
| 隔离性                      | 1.wxs 的运行环境和其他 javascript 代码是隔离的 <br />2. wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的`API` |
| 不能作为事件回调            | `wxs` 函数不能作为组件的事件回调                             |
| ios设备上比javascript运行快 | 1.由于运行环境的差异，在 `iOS` 设备上小程序内的 `wxs` 会比 `javascript` 代码快 2 ~ 20 倍。<br />2.在 `android` 设备上二者运行效率无差异 |

#### 7.3.3 wxs 遵循 commonJS 模块化规范

> `commonJS`是 javascript 的模块哈规范之一，小程序的脚本语言`wxs` 遵循了commonJS规范，因此，使用 wxs 时的体验和使用`node.js`的体验比较相似，wxs可以使用以下的 commonJS
>
> 规定成员

* module 对象：
  * 每个`wxs`都是独立的模块，每个模块均有一个内置的`module`对象，每个模块都有自己独立的作用域
* module.exports
  * 由于`wxs`拥有独立作用域，使用在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见，通过`module.exports`属性，可以对外共享模块的私有变量和函数
* require 函数
  * 在`wxs`模块中引用其他`wxs`文件模块，可以使用`require`函数

#### 7.3.4 wxs基础语法

* 通过`module.exports`属性，可以对外共享本模块的私有变量与函数

```js
var foo = “‘hello world’ from wxs”; // 定义私有变量 foo
var bar = function (d) {            // 定义私有函数 bar
  return d
}

// 通过 modules.exports 向外共享私有成员
module.exports = {
  FOO: foo, // 向外共享私有变量 foo
  bar: ba, // 向外共享私有函数 bar
};

// module.exports 中挂载 msg 变量
module.exports.msg = “some msg”
```

* 在`wxs`模块中引用其他 wxs 文件模块，可以使用 require 函数

```js
// 使用 require 导入 tools.wxs 脚本
var tools = require("./tools.wxs")

// 得到的 tools 对象，可以直接访问到 tools.wxs 中向外暴露的变量和方法
console.log(tools)
```

**注意事项：**

* 只能引用`wxs`文件模块，且**必须使用相对路径**
* `wxs`模块均是单例
  * wxs 模块在一次被引用时，会自动初始化为单例对象
  * 多个界面，多个地方，多次引用，使用的都是同一个`wxs`模块对象
* 如果一个`wxs`模块在定义之后，一直没有被引用，则改模块不会被解析与运行

#### 7.3.5 wxs支持的数据类型

> wxs 语言目前共有以下8中数据类型

| 数据类型 | 描述       |
| -------- | ---------- |
| number   | 数值类型   |
| string   | 字符串类型 |
| boolean  | 布尔类型   |
| object   | 对象类型   |
| function | 函数类型   |
| array    | 数组类型   |
| date     | 日期类型   |
| regexp   | 正则       |

**注意事项**

注意：由于`wxs` 与 `javascript` 是不同的语言，有自己的语法，并不和 `javascript` 一致，

所以在使用以上8种数据类型的时候，一定要先翻阅官方文档，再进行使用！

**参考文档： [数据类型](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/06datatype.html)**

#### 7.3.6 内嵌 `wxs` 脚本

使用规则：

* wxs 代码可以编写在 `wxml`文件的`<wxs></wxs>`标签内，就想`javascript`代码可以编写在`html`文件中的`<script></script>`标签内一样
* `wxml`文件中的每个`<wxs></wxs>`标签，**必须提供一个`module`属性**，用来指定当前`<wxs></wxs>`标签的模块名。在单个`wxml`文件内，建议其值唯一
* module 属性值的命名必须符合下面两个规则
  * 首字符必须是：字母（a-z A-Z），下划线（_）
  * 剩余字符可以是：字母（a-z A-Z），下划线（_）， 数字（0-9

**代码演示:**

```html
<view>{{ info.msg }}</view>

<wxs module='info'>
  var msg = '我在等风来'

  module.exports = {
    msg: msg
  }
</wxs>
```

#### 7.3.7 外联`wxs`脚本

使用规则：

* `wxs`代码可以编写在以`.wxs`为后缀名的文件内，就像`javascript`代码看编写在以`.js`为后缀名文件中一样
* 在`wxml`中如果要引入外联的`wxs`脚本，必须为`<wxs></wxs>`标签添加`module`和`src`属性
  * `module`用来为`<wxs></wxs>`标签指定模块名，作为当前页面访问这个模块的标识名称
  * `src`用来指定氮气<wxs></wxs>标签要引入的脚本路径，必须是**相对路径**

**代码演示:**

```js
// .wxs 文件

var msg = '风铃响,故人归'
var handle = function (params) {
    return params
}

module.exports = {
    msg: msg,
    handle: handle
}
```

```html
<wxs src='./ling.wxs' module='feng'></wxs>
<view>{{ feng.msg }}</view>
<view>{{ feng.handle('我在等风') }}</view>
```

**注意：在 `wxs`中不要使用高级的`JS`语法,就写最基础的`JS`代码

## 八、渲染

### 8.1 wx:if

* 在小程序中，使用`wx:if="{{condition}}"`来判断是否需要渲染代码块：

```html
<view wx:if="{{condition}}"> True </view>
```

* 也可以用`wx:elif`和`wx:else`来添加一个else块 注：length 在Page({data:{}})中绑定

```html
<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view
```

**block wx:if**

* 由于`wx:if`是一个控制属性，需要将它添加到一个标签上，如果要一次性判断多个组件标签，可以使用一个`<block></block>`标签将多个组件包装起来，并在上边使用`wx:if`控制属性
* `</block />`**并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性**

```html
<block wx:if='{{ id == 10 }}'>
    <view>JavaScript</view>
    <view>HTML</view>
    <view>CSS</view>
</block>
```

### 8.2 hidden

* 使用 `hidden="{{condition}}"也能控制元素的显示与隐藏`,true 为隐藏，false为显示

```html
 <view hidden='{{ id > 10 }}'>前端三板斧</view>
```

**hidden和 `wx:if`的区别**

* 被`wx:if`控制的区域，框架有一个局部渲染的过程，会根据控制条件的改变，改变创建或销毁对应的`UI`结构
* `wx:if`是惰性的，如果在初始渲染条件为 `falses`,框架什么也不做，在条件第一次变成真的时候才开始局部渲染
* 相比之下，`hidden`就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏

**总结:**

`wx:if`有更高的切换消耗，而`hidden`有更高的初始化渲染消耗,因此，如果在需要频繁切换的情景下，用`hidden`更好，如果在运行时条件不太可能改变则`wx:if`较好

### 8.3 wx:for 列表渲染

* 在组件上使用`wx:for`控制属性绑定一个数组，即可使用数组中各项的数据重复渲染改组件
* 默认数组的当前项的下标变量名默认为`index`，数组氮气项的变量默认为`false`

```html
<view wx:for='{{ arr }}' wx:key='index'>
    我是{{ item }} -- 索引是 {{ index }}
</view>
```

**`block wx:for`**

* `wx:for`可以用在`<block></block>`标签上，以渲染一个包含多节点的结构快

```html
<block wx:for='{{ arr }}' wx:key='index'>
    <view>值：{{item}} -- 索引{{index}}</view>
</block>
```

**指定索引和当前项的变量名**

* 使用`wx:for-item` 可以指定数组当前元素的变量名
* 使用`wx:for-index` 可以指定数组当前下标的变量名

```html
<view wx:for='{{ arr }}' wx:for-item='foritem' wx:for-index='forindex' wx:key='index'>
    我是{{ foritem }} -- 索引是 {{ forindex }}
</view>
```

**列表渲染中的`wx:key`**

1. `wx:key`的作用说明
   * 如果列表中项目的位置会动态改变或者新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态。(如`<input />`中的输入内容，`<checkbox />`的选中状态 )，需要使用`wx:key`来指定列表中项目的唯一的标识符。当数据改变触发渲染层重新渲染的时候，会校郑带有 `key`的组件，**框架会确保他们被重新排序，而不是重新创建**，以确保组件报错自身的状态，并且提高列表渲染时的效率。
2. `wx:key`的注意事项
   * `key`值必须具有唯一性，且不能动态改变
   * `key`的值必须是数字或字符串
   * 保留关键字 `*this` 代表在 `for` 循环中的 `item` 本身，它也可以充当 `key` 值，但是有以下限制：需要 `item` 本身是一个唯一的字符串或者数字。
   * 如不提供 `wx:key`，会报一个 `warning`， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。
   * 在绑定`wx:key`的时候不需要使用`Mustache`语法，这接写就完事,例如`wx:key='index'`

## 九、事件

### 9.1 下拉刷新

> 概念：下拉刷新是移动端更新列表数据的交互行为，用户通过手指在屏幕上`自上而下的滑动`，可以触发页面的下拉刷新，更新列表数据
>
> 应用场景：在移动端，数据列表是常见的页面效果，更新列表是最基本的页面需求，想比于按钮刷新，定时刷新来说，下拉刷新的用户体验方便友好，已经成为移动端刷新列表数据的最佳解决方案。

![下拉刷新](/medias/imges/xcx/product/img6.png)

#### 9.1.1 如何启动下拉刷新 

* 在`app.json`的`window`选项中或页面配置中开启`enablePullDownRefresh:true`
* 可以通过`wx.startPullDownRefresh()`触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。

**注意：一般情况下，推荐在页面配置中为需要的页面单独开启下拉刷新行为**

#### 9.1.2 设置下拉刷新窗口的样式

> 在app.json或页面级的.json文件中的window选项下属性配置

| 属性                | 描述                                                   |
| ------------------- | ------------------------------------------------------ |
| backgroundColor     | 用来配置下拉属性窗口的背景色颜色，仅支持16进制颜色值   |
| backgroundTextStyle | 用来配置下拉刷新`loading`的样式，仅支持`dark`和`light` |

#### 9.1.3 监听下拉属性事件

> 需要先开枪下拉刷新，为页面添加`onPullDownRefresh()`函数，可以监听用户在当前页面的下拉刷新事件

```js
/**
 * 页面相关事件处理函数--监听用户下拉动作
 */
onPullDownRefresh: function () {
    console.log('触发下拉刷新啦')
}
```

#### 9.1.4 停止下拉刷新

> 处理完下拉刷新后，下拉刷新的`loading`效果会一直显示，不会主动消失，因此需要手动隐藏下拉刷新的lading效果，调用`wx.stopPullDownRefresh()`可以停止当前页面的下拉刷新。

```js
/**
 * 页面相关事件处理函数--监听用户下拉动作
 */
onPullDownRefresh: function () {
    console.log('触发下拉刷新啦')

    wx.stopPullDownRefresh()
}
```

### 9.2 上拉刷新

> 概念：在移动端，随着手机不断向上滑动，当内容将要到达屏幕底部的时候，页面会随之不断的加载后续内容，直到满意新内容为止，我们称之为上拉加载更多。上拉加载更多的本质就是暑假的分页加载。
>
> 应用场景：在移动端，列表数据的分页加载，首选的实现方式就是上拉加载更多。

#### 9.2.1 设置上拉刷新的距离

* 在`app.json`的`window`选项中或页面配置中设置触底距离`enablePullDownRefresh:xxx`，单位为`px`，默认触底距离是为`px`
* 为页面添加`onReachBottom()`函数，可以监听用户在当前页面的上拉触底事件，从而实现上拉加载更多列表数据的效果

```js
/**
 * 页面上拉触底事件的处理函数
 */
onReachBottom: function () {
    console.log('触发上拉刷新啦')
},
```

### 9.3 页面滑动事件`onPageScroll`

* 监听用户滑动页面事件,得到`scrollTop`,页面在垂直方向已滚动的距离(单位`px`)

```js
onPageScroll: function (e) {
    console.log(e)
}
```

### 9.4 分享事件`onShareAppMessage`

* 监听用户点击页面内转发按钮(`<button>组件 open-type="share"`)
* 右上角菜单`转发`按钮的行为，并自定义转发内容

| 参数       | 类型   | 描述                                                         |
| ---------- | ------ | ------------------------------------------------------------ |
| from       | string | 转发事件来源，`button`页面内转发按钮，`menu`：右上角转发菜单 |
| target     | object | 如果 from 值是 button，则target 是触发这次转发事件的 button，否则为`undefined` |
| webViewUrl | string | 页面中包含`<web-view>`组件时，返回当前`<web-view>`的url      |

* 自定义转发内容，return 一个Object 就可以

| 字段     | 说明                                                         | 默认值                                    |
| -------- | ------------------------------------------------------------ | ----------------------------------------- |
| title    | 转发标题                                                     | 氮气小程序名称                            |
| path     | 转发路径                                                     | 当前页面 path，必须是以 `/`开头的完整路径 |
| imageUrl | 自定义图片路径，可以是本地文件路径，代码包文件路径或者网络图片路径，支持`PNG`及`JPG`,显示图片长宽比是 5:4 | 使用默认截图                              |

```js
Page({
    onShareAppMessage: function (res) {
        if (res.from === 'button') {
            // 来自页面内转发按钮
            console.log(res.target)
        }
        return {
            title: '自定义转发标题',
            path: '/page/user?id=123'
        }
    }
})
```

### 9.5 点击 tab 时触发事件`onTabItemTap`

> 直接在tabBar对应的页面下的`.js`文件下注册该事件即可

| 参数     | 类型   | 描述                             |
| -------- | ------ | -------------------------------- |
| index    | string | 被点击`tabItem`的序号，从 0 开始 |
| pagePath | string | 被点击`tabItem`的页面路径        |
| text     | string | 被点击`tabItem`的按钮文字        |

```js
onTabItemTap(item) {
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
}
```

## 十、页面导航

### 10.1 声明式导航

* 导航到非`tabBar`页面

> 非`tabBar`页面指的是没有被当做`tabBar`进行切换的页面

```html
<navigator url="/pages/about/about">跳转到 about 页面</navigator>
```

注意：

1. `url`属性设置需要跳转的路径，应该以`/`开头
2. 路径必须提前在`app.json`的`pages`节点下声明

* 导航到`tabBar`页面

> navigator 组件单纯使用`url`属性，无法导航到`tabBar`页面，必须需要结合`open-type`属性进行导航

```html
<navigator url="/pages/person/person" open-type="switchTab">跳转到 tabBar 页面</navigator>
```

* 后退导航

> 小程序如果要后退到上一页或多级页面，需要把`open-type`设置为`navigateBack`，同时使用`delta`属性指定后退的层数

```html
<navigator open-type='navigateBack' delta='1'> 返回上一页 </navigator>

<navigator open-type='navigateBack' delta='2'> 返回上上一页 </navigator>
```

* 导航传参

> `navigator`组件的`url`属性用来指定导航到的页面路径，同时路径后面还可以携带参数，参数与路径之间使用`?`分隔，参数键与参数值用`=`相连，不同参数用`&`分隔

```html
<navigator url="/pages/about/about?age=18&name=shuji">跳转到 about 页面</navigator>
```

* 接受传递的参数

> 不论声明式还是编程式导航，最终导航到的页面可以在`onLoad`生命周期函数中接收传递过来的参数

```js
onLoad: function (options) {
    // 打印传递出来的参数
    console.log(options)
},
```

### 10.2 编程式导航

* 导航到非`tabBar`页面

> 通过`wx.navigateTo(Object Object)`方法，可以跳转到应用内的某个页面，但是不能跳到`tabBar`页面
>
> [详细文档](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html)

| 属性     | 类型     | 是否必填 | 描述                                                         |
| -------- | -------- | -------- | ------------------------------------------------------------ |
| url      | string   | 是       | 需要条状的应用内啡`tabBar`的页面的路径，路径后库带参数，参数与路径之间使用`?`分隔，参数键与参数值用`=`相连，不同的参数用`&`分隔；如：‘path?key=value&key2=value2’ |
| success  | function | 否       | 接口调用成功的回调函数                                       |
| fail     | function | 否       | 接口调用失败的回调函数                                       |
| complete | function | 否       | 接口调用结束的回调函数(调用成功、失败都会执行)               |

```js
// 跳转到非导航页面
handle: function () {
    wx.navigateTo({
        url: '/pages/about/about',
        success: function () {
            console.log('Hello about')
        }
    })
},
```

* 导航到`tabBar`页面

> 通过`wx.switchTab(Object Object)`方法，可以跳转到`tabBar`页面，并关闭其他所有非`tabBar`页面
>
> [详细文档](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html)

| 属性     | 类型     | 是否必填 | 描述                                                         |
| -------- | -------- | -------- | ------------------------------------------------------------ |
| url      | string   | 是       | 需要跳转的`tabBar`页面的路径(需要在`app.json`的tabBar 字段定义的页面)，路径后不能带参数 |
| success  | function | 否       | 接口调用成功的回调函数                                       |
| fail     | function | 否       | 接口调用失败的回调函数                                       |
| complete | function | 否       | 接口调用结束的回调函数(调用成功、失败都会执行)               |

```js
// 跳转到 tabBar 页面
tabBarHandle: function () {
    wx.switchTab({
        url: '/pages/person/person',
        success: function() {
            console.log('Hello Person')
        }
    })
},
```

* 后退导航

> 通过`wx.navigateBack(Object Object)`方法，关闭当前页面，返回上一页面或多级页面
>
> [详细文档](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html)

| 属性     | 类型     | 是否必填 | 描述                                                   |
| -------- | -------- | -------- | ------------------------------------------------------ |
| delta    | string   | 是       | 返回的页面数，如果 `delta`大于现有页面数，则返回到首页 |
| success  | function | 否       | 接口调用成功的回调函数                                 |
| fail     | function | 否       | 接口调用失败的回调函数                                 |
| complete | function | 否       | 接口调用结束的回调函数(调用成功、失败都会执行)         |

```js
handle: function () {
    wx.navigateBack({
        delta: 1
    })
},

    twoHandle: function () {
        wx.navigateBack({
            delta: 2
        })
    },
```

* 导航传参

> `wx.navigateTo(Object Object)`方法的`Object`蚕食中，`url`属性用来指定需要田庄的应用内非`tabBar`的页面的路径，路径后面可以带参数。参数与路径之间使用`?`分隔，参数键与参数值用`=`相连，不同参数用`&`分隔

```js
// 跳转到 tabBar 页面
tabBarHandle: function () {
  wx.switchTab({
    url: '/pages/person/person?age=18&name=shuji',
    success: function() {
      console.log('Hello Person')
    }
  })
},
```

* 接受传递的参数

> 不论声明式还是编程式导航，最终导航到的页面可以在`onLoad`生命周期函数中接收传递过来的参数

```js
onLoad: function (options) {
    // 打印传递出来的参数
    console.log(options)
},
```

## 十一、网络请求

### 11.1 小程序后台配置

* 每个微信小程序需要事先设置一个通讯域名，小程序只可以跟指定的域名进行网络通讯
* 服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置，配置时需要注意：
  - 域名只支持 `https` (`request`、`uploadFile`、`downloadFile`) 和 `wss` (`connectSocket`) 协议
  - 域名不能使用 `IP` 地址或 `localhost`
  - 域名必须经过 `ICP` 备案
  - 服务器域名一个月内可申请5次修改

**注意： [网络配置详情](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)**

### 11.2  跳过域名校验

* 在微信开发者工具中，库临时开启 「开发环境不校验请求域名、TLS 版本及 HTTPS 证书」 选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。

**注意：在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。**

**注意： [网络配置详情](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)**

### 11.3 发送网络请求

> 小程序发送请求使用`wx.request()`方法

* GET

```js
getData: function () {
    wx.request({
        url: 'xxxx',
        method: 'get',
        success: function (res) {
            console.log(res)
        }
    })
},
```

* POST

```js
postData: function () {
    wx.request({
        url: 'xxxx',
        method: 'post',
        data: {
            name: 'ls'
        },
        success: function (res) {
            console.log(res)
        }
    })
},
```

**注意： method 如果不进行配置，默认参数是 get 请求方式**

**[wx.request  详细文档说明](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)**

### 11.4 小程序中没有跨域限制

* 在普通网站开发中，由于浏览器的同源策略限制，存在数据的跨越请求问题，从而衍生出了`JSONP`和`CORS`两种主流的跨域问题解决方案
* 注意：小程序的内部运行机制与网页不同，小程序中的代码并不用运行在浏览器中，因此小程序开发中，不存在数据的跨域请求限制问题

## 十二、小程序组件

### 12.1 组件的创建

* 在项目的根目录中，鼠标右键，创建`commponents 文件夹 -> 在建立组件目录`
* 在上步的组件目录下，鼠标右键，点击`新建Component`
* 为新建的组件命名之后，会自动生成组件对应的 4 个文件，后缀名分别为`.js`,`.json`,`.wxml`和`.wxss`
* [组件创建详细文档](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)

**注意：应当尽量将不同的组件，存放到单独的文件夹中，从而保证清晰的目录结构**

### 12.2 组件的引用

* 在需要引用组件的页面中，找到页面的`.json`配置文件，新增`usingComponents`阶段
* 在`usingComponents`中，通过键值对的形式，注册组件；键为注册的组件名称，值为组件的**相对路径**
* 在页面的`.wxml`文件中，把注册的组件名称，以**标签形式在页面上使用**，即可把组件展示到页面上，例如下述的注册组件可以用`<first-com></first-com>`来展示

```json
{
  "usingComponents": {
    "first-com": "../../component/com01/com01"
  }
}
```

**注册组件名称时，建议把组件名称使用中横线进行连接，例如上述的`first-com`**

### 12.3 组件样式

> [小程序组件样式 详细文档](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)

组件对应的`wxss`文件样式，只对组件`wxml`内的节点生效，编写组件样式时，需要注意以下几点：

* 组件和引用组件的页面不能使用`id选择器(#a)、属性选择器([a])和标签名选择器`,请改用`class`选择器
* 组件和引用组件的页面中使用后代选择器(.a .b) 在一些极端情况下回有非预期的标签，请避免使用
* 子元素选择器(.a > .b ),只用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况
* 继承样式，如`font`、`color`,会从组件外继承到组件内
* 除继承样式外，`app.wxss`中的样式，组件所在页面的样式对自定义组件无效

**注意：以上语法不推荐死记硬背，建议写样式的时候使用 class选择器就完事**

### 12.4 组件的数据与方法

> [组件详细的参数含义和使用](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)

#### 12.4.1 使用 data  定义组件的私有数据

小程序组件中的 data ，和小程序页面的 data  用法一致，只不过：

* 页面的 data 定义在`Page()`组件中
* 组件的 data 定义在 `Component()`函数中

在组件的`.js`文件中:

* 如果要访问 data 中的数据，直接使用`this.data.数据名称`即可
* 如果要为 data 中的数据重新赋值，调用`this.setData({数据名称：新值})`即可

在组件的`.wxml`文件

* 如果要渲染 data 中的数据，直接使用`{{数据名称}}`即可

#### 12.4.2 使用 methods 定义组件的事件处理函数

> [组件间通信与事件 详细文档](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html)

和页面不同，组件的事件处理函数，必须定义在`methods`节点中，例如

```js
methods: {
    handle: function () {
        console.log('组件的方法要定义在 methods 中')

        this.setData({
            num: this.data.num + 1
        })

        console.log(this.data.num)
    }
}
```

### 12.5 组件的 properties  

#### 12.5.1 properties 简介

> properties是组件对外属性，用来接收外界传递到组件中的数据，类似 vue 中的 `props`，但vue的props在组件中只有只读属性，并不能修改

组件的`properties`和`data`的用法类似，它们都是可读可写的，只不过：

* `data` 更倾向于存储组件的私有数据
* `properties`更倾向于存储外界传递到组件中的数据

 **语法结构:**

```js
Component({
    properties: {
        // 完整的定义方式
        propA: { // 属性名
            type: String, // 属性类型
            value: '' // 属性默认值
        },
        propB: String // 简化的定义方式
    }
})
```

注意： type的可选值为 Number,String ,Boolean , Object , Array , null (表示不限制类型)

#### 12.5.2 为组件传递 properties 的值

可以使用数据绑定的形式，向子组件的属性传递动态数据，例如：

```html
<!-- 引用组件的页面模板 -->
<view>
    <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    </component-tag-name>
</view>
```

在以上例子中，组件的属性`propA`和`propB`将收到页面传递的数据，页面可以通过`setData`来改变绑定的数据字段

注意：在定义 properties 时，属性名采用驼峰写法( propA );在 wxml 中，指定属性值，则对应使用连接字符写法 (prop-a="{{xxx}}"),应用于数据绑定时，采用驼峰写法 ( attr = "{{propA}}" )

```js
// 组件 com02.js
properties: {
    propPrice: {
        type: Number,
            value: 1
    }
},
```

```html
<!-- 引用组件的页面 -->
<second-com prop-price="{{ priceData }}"></second-com>

<view>{{ propPrice }}</view>
```

#### 12.5.3 在组件内修改 properties 的值

小程序中，properties 的值是可读可写的，它的用法于 data几乎一致，因此可以通过 `setData`修改`properties`中任何属性的值，例如：

```js
properties: {
 properties: Number
},
methods: {
  handle: function () {
    this.setData({
      propPrice: this.properties.propPrice + 1
    })

    console.log(this.properties.propPrice)
  }
}
```

### 12.6 数据监听器

> 数据监听器可以用于`监听`和`响应`任何属性和数据字段的变化,不论是 data 还是 properties 数据，也可以说是被`Mutache`绑定的数据都可以被监听，从而执行特定的操作，作用类型于 vue 中的 `watch`，数据监听器从小程序基础库版本`2.6.1`开始支持，数据监听器的基本语法格式如下:

```js
Component({
    observers: {
        '字段A, 字段B': function(字段A的新值，字段B的新值) {
            // do something
        }
    }
})
```

1. 监听子数据字段的变化

```js
Component({
    observers: {
        'name, propCount': function(newName, newpropCount) {
            console.log('最新的name是：' + newName)
            console.log('最新的propCount是：' + newpropCount)
        }
    }
})
```

2. 使用通配符`**`监听所有子数据字段的变化

```js 
Component({
    observers: {
        'some.field.**': function (field) {
            // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
            // （除此以外，使用 setData 设置 this.data.some 也会触发）
            field === this.data.some.field
        }
    }
})
```

### 12.7 组件的生命周期

> 组件的生命周期，指的是组件自身的一些函数，这些函数在特定的时间点或遇到一些特殊的框架事件时被自动触发

1. 组件的生命周期，标色的为主要生命周期

| 生命周期名                                                  | 参数         | 描述                                                         |
| ----------------------------------------------------------- | ------------ | ------------------------------------------------------------ |
| **created**                                                 | 无           | 组件实例刚刚被创建好时， created 生命周期被触发。此时还不能调用 setData 。 通常情况下，这个生命周期只应  该用于给组件 this 添加一些自定义属性字段。 |
| 该用于给组件 this 添加一些自定义属性字段。**attached**      | 无           | 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化完毕。这个 生命周期很有用，绝大多数初始化工作可以在这个时机进行 |
| 生命周期很有用，绝大多数初始化工作可以在这个时机进行。ready | 无           | 在组件在视图层布局完成后执行                                 |
| moved                                                       | 无           | 在组件实例被移动到节点树另一个位置时执行 j                   |
| **detached**                                                | 无           | 在 组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则  detached 会被触发。 |
| error                                                       | Object Error | 每当组件方法抛出错误时执行                                   |

2. 定义生命周期函数

生命周期方法可以直接定义在`Component`构造器的第一级参数中，自小程序基础库`2.2.3`起，组件的生命周期也可以在`lifetime`字段内进行声明(这是推荐的方式，其优先级最高)

```js
Component({
    lifetimes: {
        attached() {}, // 在组件实例进入页面节点树时执行
        detached() {}, // 在组件实例被从页面节点树移除时执行
    },
    // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
    attached() {}, // 在组件实例进入页面节点树时执行
    detached() {}, // 在组件实例被从页面节点树移除时执行
    // ...
})
```

3. 组件所在页面的生命周期

有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为`组件所在页面的生命周期`，在`pageLifetimes`定义段中定义，其中可用的生命周期包括

| 生命周期 | 参数        | 描述                         |
| -------- | ----------- | ---------------------------- |
| show     | 无          | 组件所在的页面被展示时执行   |
| hide     | 无          | 组件所在的页面被隐藏时执行   |
| resize   | Object Size | 组件所在的页面尺寸变化时执行 |

```js
Component({
    pageLifetimes: {
        show() { // 页面被展示
        },
        hide() { // 页面被隐藏
        },
        resize(size) { // 页面尺寸变化
        }
    }
})
```

### 12.8 组件插槽

在组件的 `wxml`中可用包含 `slot`节点，用于承载组件使用者 提供的 wxml 结构，默认情况下，一个组件的 wxml 中只能有一个 slot ，需要使用 多 个`slot`时，库在组件的`.js`中声明启用

注意：小程序中目前只有默认插槽和多个插槽，暂不支持作用域插槽

1. 默认插槽

```html
<!-- 组件模板 -->
<view class="wrapper">
    <view>这里是组件的内部节点</view>
    <slot></slot>
</view>

<!-- 引用组件的页面模板 -->
<view>
    <component-tag-name>
        <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
        <view>这里是插入到组件slot中的内容</view>
    </component-tag-name>
</view>
```

2. 启用多个插槽

在组件中，需要使用多`slot`，可以在组件`.js`中声明启用，例如

```js
Component({
    options: {
        multipleSlots: true // 在组件定义时的选项中启用多slot支持
    },
    properties: { /* ... */ },
    methods: { /* ... */ }
})
```

3. 定义多个插槽

可以在组件的 wxml 中使用多个 slot 标签，以不同的 `name`来区分不同的插槽，例如

```html
<!-- 组件模板 -->
<view class="wrapper">
    <slot name="before"></slot>
    <view>这里是组件的内部细节</view>
    <slot name="after"></slot>
</view>
```

使用时，用 slot 属性来将节点插入到不同的 slot 中。示例代码如下 

```html
<!-- 引用组件的页面模板 -->
<view>
    <component-tag-name>
        <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
        <view slot="before">这里是插入到组件slot name="before"中的内容</view>
        <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
        <view slot="after">这里是插入到组件slot name="after"中的内容</view>
    </component-tag-name>
</view>
```

### 12.9 组件间的通信

组件之间的三种基本通信方式：

* WXML 数据绑定： 用于父组件向子组件的指定属性传递数据，仅能设置 `JSON`兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）
* 事件：用于子组件向父组件传递数据，可以传递任意数据。 
* 如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。

#### 12.9.1 this.selectComponent(string)

在小程序的组件中，调用`this.selectComponent(string)`，可以返回特定组件的实例对象，例如

```html
<!-- wxml -->
<component-a class="customA" id= "cA" ></component-a>
<!--父组件的 .js 文件中，可以调用 selectComponent 函数并指定 id 或 class 选择器，获取子组件对象-->
Page({
onLoad(){
// 切记下面参数不能传递标签选择器（component-a），不然返回的是 null
var component = this.selectComponent('.customA'); // 也可以传递 id 选择器 #cA
console.log(component);
}
})
```

#### 12.9.2 通过事件监听实现子向父传值

事件系统是组件间通信的主要方式之一，自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。

通过事件监听实现子组件向父组件传值的步骤

* 在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件
* 在父组件的 wxml 中， 通过自定义事件的形式，将步骤 一 中定义的函数引用，传递给子组件
* 在子组件的 js 中，通过调用`this.triggerEvent('自定义事件名称'，{参数对象})`,将数据发送到父组件
* 在父组件的 js 中， 通过 `e.detail`获取到子组件中传递过来的数据

## 十三、小程序中开发易忽略的点

### 13.1 更新数据

其实我们不调用`this.setData()`方法来更新数据，而是通过`this.data.xxx=xxx`类似赋值更新操作，这个可以说只是在内存中给`data`上更新了数据，**并不在视图层面上更新**，而`this.setData()`更新则是内存和视图层面都更新，那么在一些特殊情况下，我们可以将两个合理运用来满足我们的需求，例如我们要对`data`中的数据进行多次运算和赋值，那么我们可以使用`this.data.xxx=xxx`的方式，将`data`节点看做数据更新的`暂存地`，之后再进行多次运算或其他赋值操作，我们在一次性的使用`this.setData`方法往视图和内存层面更新我们的数据。