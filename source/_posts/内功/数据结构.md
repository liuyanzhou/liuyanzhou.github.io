---
title: 数据结构
date: 2021-03-24 17:10:37
categories: 内功
top: true
summary: 数据结构
tags: 
 - 内功

---

### 数据结构

什么是算法？

> 算法是用于解决特定问题的一系列的执行步骤

如何评判一个算法的好坏？

> 我们可以写一个时间的执行函数，记录程序开始执行的时间，用程序结束的执行时间相减得出总体时间。这个方法称为`事后统计法`，它的缺点是：
>
> * 执行时间严重依赖硬件以及运行时各种不确定的环境因素
> * 必须编写相应的测算代码
> * 测试数据的选择比较难保证公正性
>
> 所以我们急需要设置一个评估算法的标准，来判断算法的正确性，可读性，健壮性，由此应运而生的复杂度的评估：
>
> * 时间复杂度（time complexity）：估算程序指令的执行次数（执行时间）
> * 空间复杂度（space complexity）：估算所需占用的存储空间

什么是数据结构：

![数据结构](/medias/imges/arithmetic/compx4.jpg)

### 一、复杂度

> 一般用大`O`表示法来描述复杂度，它表示的是数据规模`n`对应的复杂度

* 忽略常数、系数、低阶
* 9  >> O(1)
* 2n+3 >> O(n)
* n^2 + 2n + 6 >> O(n^2)
* 4n^3+3n^2+22n+100 >> O(n^3)
* 对数阶一般省略底数，因为`long(2)n = log(2)9 * log(9)n`，所以  log(2)n、log(9)n 统称为`log(n)`
* 多个数据规模，例如下面，时间复杂度为`O(n+m)`

```js
function test(n,m) {
    for(let i=0;i<n;i++) {
        console.log(i)
    }
    for(let i=0;i<m;i++) {
        console.log(i)
    }
}
```

> 注意：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率

**复杂度分析分为**

* 最好情况复杂度
* 最坏情况复杂度
* 平均情况复杂度
* 均摊复杂度（特殊）

> 这得看我们的n(数据规模与我们该方法的关系，把复杂度拆分为以上三种)

均摊复杂度的情况在我们动态数组的`add()`中的扩容操作有可能出现，当我们普通添加元素的时候，复杂度为`O(1)`，但当我们数组需要扩容时，复杂度为`O(n)`，这一下增加的复杂度我们可以将其分摊到前面每个复杂度上，最后复杂度也就是`O(1)`。

**常见的复杂度：**

![常见复杂度](/medias/imges/arithmetic/compx.jpg)

**数据规模较小时：**

![数规规模较小时](/medias/imges/arithmetic/compx1.jpg)

**数据规模较大时：**

![数规规模较大时](/medias/imges/arithmetic/compx2.jpg)

**斐波那契数列算法**

从第3个数开始值为前面两个数值的和

> 0 1 1 2 3 5 8 13

* 递归版本

```js
// 时间复杂度为 O(2^n)
function fib1(n) {
    if (n <= 1) return n
    return fib1(n - 1) + fib1(n - 2)
}
console.log(fib1(3))
```

* 迭代版本

```js
// 时间复杂度为 0(n)
function fib2(n) {
    
    let second = 1;
    // o(n)
    for (let i = 0; i < n - 1; i++) {
        let sum = first + second;
        first = second;
        second = sum;
    }
    return second;
}
console.log(fib2(3))

// 改良
function fib3(n) {
    if (n <= 1) return n;
    let first = 0;
    let second = 1;
    for (let i = 0; i < n - 1; i++) {
        second += first;
        first = second - first
    }
    return second
}
console.log(fib3(3))
```

算法优化方向：

* 用尽量少的存储空间
* 用尽量少的执行步骤（执行时间）
* 根据情况，可以`空间换时间`、`时间换空间`

### 二、线性表

线性表是具有n个相同类型元素的有限序列（n>=0）

>索引  0        1        2                     n-3        n-2         n-1
>
>​          a1 -> a2 -> a3 -> ....  -> a(n-2) -> a(n-1) -> a(n)

* a1是首节点（首元素），a(n)是尾节点（尾元素）
* a1 是 a2 的前驱，a2是a1的后继

常见的线性表有：数组、链表、栈、队列、哈希表（散列表）

#### 数组（Array）

> 数组是一种顺序存储的线性表，所有元素的内存地址是连续的

```js
let arr = new Array(n)
```

我们手动实现一个动态数组，功能

* clear()   -> 清空数组
* getSize() -> 获取数组中可访问元素的长度
* isEmpty() -> 数组是否为空
* contains(element) -> 判断数组是否包含element元素
* get(index) -> 根据索引返回数组对应的元素
* set(index,element) -> 修改index对应的元素
* add(index,element) -> 增加数组元素
* remove(index) -> 删除index对应的数组元素
* indexOf(element) -> 获得element在数组那个索引位置
* ensureCapacity(capacity) -> 对数组的扩容
* checkArray(index)\checkArrayAdd(index) -> 检查索引是否越界
* toString() -> 数组打印

 ```js
class ArrayList {
    constructor(arraySize) {
        const DEFAULT_NUMBER = 3;
        this.size = 0;
        this.arraySize = arraySize < DEFAULT_NUMBER ? DEFAULT_NUMBER : arraySize
        this.elements = new Array(this.arraySize);
    };
    //   清除数组
    clear() {
        for (let i = 0; i < this.size; i++) {
            // 将删除的数组对象类型元素对应的地址也删除，让其被垃圾回收
            this.elements[i] = null;
        }
        this.size = 0;
    };
    // 元素数量
    getSize() {
        return this.size;
    };
    // 是否为空
    isEmpty() {
        return this.size == 0;
    };
    //师傅包含某个元素
    contains(element) {
        return this.indexOf(element) !== -1
    };

    // 获取index位置的元素
    // 返回元素
    get(index) {
        this.checkArray(index)
        return this.elements[index];
    };
    // 设置index位置的元素
    // 返回原来的元素
    set(index, element) {
        this.checkArray(index);
        let old = element[index];
        element[index] = element
        return old
    };
    // 在index位置插入一个元素
    add(index, element) {
        let args = arguments.length
        this.ensureCapacity(this.size + 1)
        if (args == 1) {
            element = index;
            this.elements[this.size++] = element;
        } else {
            this.checkArrayAdd(index);
            for (let i = this.size; i > index; i--) {
                this.elements[i] = this.elements[i - 1]
            }
            this.elements[index] = element;
            this.size++
        }

    };
    // 删除index的元素
    // 返回删除的元素
    remove(index) {
        this.checkArray(index);
        let old = this.elements[index]
        for (let i = index + 1; i < this.size; i++) {
            this.elements[i - 1] = this.elements[i]
        }
        // 将删除的数组对象类型元素对应的地址也删除，让其被垃圾回收
        this.elements[--this.size] = null;
        return old;
    };
    // 查看元素的索引
    // 找到返回元素的索引，否则返回-1
    indexOf(element) {
        for (let i = 0; i < this.arraySize; i++) {
            if (this.elements[i] == element) return i
        }
        return -1;
    };
    // 扩容数组:就是参加一个新的容量较大的数组，在将老数组的值复制到新数组上
    ensureCapacity(capacity) {
        let oldCapacity = this.elements.length;
        if (oldCapacity >= capacity) return
        let newCapacity = oldCapacity + (oldCapacity >> 1);
        let newArray = new Array(newCapacity);
        for (let i = 0; i < oldCapacity; i++) {
            newArray[i] = this.elements[i];
        }
        this.elements = newArray
        console.log(oldCapacity, '数组的容量扩容为', newArray.length)
    };
    // 检测是否越界访问
    checkArray(index) {
        if (index < 0 || index >= this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
    checkArrayAdd(index) {
        if (index < 0 || index > this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }

    // 打印数组
    toString() {
        let str = ''
        for (let i = 0; i <= this.size; i++) {
            if (this.elements[i] !== '' && (typeof this.elements[i] !== 'undefined')) {
                if (i !== 0) {
                    str += ','
                }
                if (typeof this.elements[i] == 'object') {
                    str += JSON.stringify(this.elements[i]);
                } else {
                    str += this.elements[i]
                }
            }
        }
        return `this array's size is ${this.size},  elements:[${str}]`
    }
}
exports.ArrayList = ArrayList
 ```

**动态数组的缩容**

> 如果内存使用比较紧张，动态数组有比较多的剩余空间，我们就可以考虑缩容操作，比如剩余空间占总量的一半时，就进行缩容，但如果扩容倍数，缩容时机设计不得当，有可能会导致复杂度震荡，为了避免这个震荡的发生，我们要控制`缩容的倍数 * 扩容的倍数!== 1`即可

我们在对上面的动态数组的`remove()`操作进行改写

```js
class ArrayList {
    remove(index) {
        this.checkArray(index);
        let old = this.elements[index]
        for (let i = index + 1; i < this.size; i++) {
            this.elements[i - 1] = this.elements[i]
        }
        this.elements[--this.size] = null;
        this.trim();
        return old;
    };
    trim() {
        let capacity = this.elements.length;
        let newCapacity = (capacity >> 1);
        if (this.size >= (newCapacity) || newCapacity <= this.DEFAULT_NUMBER) return
        // 剩余空间还很多
        console.log(capacity, '缩容为', newCapacity, 'size的值', this.size)
        let newArray = new Array(newCapacity);
        for (let i = 0; i < newCapacity; i++) {
            newArray[i] = this.elements[i];
        }
        this.elements = newArray;

    };
}
```

#### 链表（linked List）

##### 1、单向链表

动态数组有个明显的缺点：

> 可能会造成内存空间的大量浪费，因为它是通过动态扩容的方式（往堆空间申请一个更大的内存空间【原来的1.5倍】来替换之前的数组数据，这就有可能造成我们申请的空间没去用）。

有没有一种数据结构是我们用多少内存就向内存申请多少内存呢？

> 链表能办到这点。链表是一种**链式存储**的线性表，所有元素的内存地址不一定是连续的

![链表](/medias/imges/arithmetic/link.jpg)

自己实现链表结构：

* clear() ---> 清除元素
* getSize() ---> 获取元素数量
* isEmpty() ---> 判断元素是否为空
* contains(element) ----> 判断元素是够被包含在链表结构内
* set(index,element) ----> 设置index对应元素的值
* add(index,element) ----> 往链表中添加元素
* getNode(index) ----> 获取index对应的元素值
* remove(index) ----> 删除index对应的元素
* indexOf(index) ---> 查找元素在链表中的索引值
* checkLink (index) / checkLinkAdd(index) ---> 检查索引越界问题

`LinkList.js`

```js
const { Node } = require('./element.js');
class LinkList {
    constructor() {
        this.size = 0;
        this.first = null;
    };
    //   清除元素
    clear() {
        this.size = 0;
        this.first = null;
    };
    // 元素数量
    getSize() {
        return this.size;
    };
    // 是否为空
    isEmpty() {
        return this.size == 0;
    };
    //师傅包含某个元素
    contains(element) {
        return this.indexOf(element) !== -1
    };
    // 设置index位置的元素
    // 返回原来的元素
    set(index, element) {
        let node = this.getNode(index);
        let oldElement = node.element;
        node.element = element;
        return oldElement
    };
    // 在index位置插入一个元素
    add(index, element) {

        let args = arguments.length
        if (args == 1) {
            element = index;
            index = this.size
        }
        this.checkLinkAdd(index)
        if (index == 0) {
            this.first = new Node(element, this.first);
        } else {
            // this.checkLinkAdd(index);
            let prev = this.getNode(index - 1);
            prev.next = new Node(element, prev.next);
        }
        this.size++

    };
    // 获取index的节点对象
    getNode(index) {
        this.checkLink(index);
        let node = this.first;
        console.log(node)
        for (let i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    };
    // 删除index的元素
    // 返回删除的元素
    remove(index) {
        let removeNode = this.first;
        if (index == 0) {
            removeNode = this.first;
            this.first = this.first.next;
        } else {
            let prev = this.getNode(index - 1);
            removeNode = prev.next;
            prev.next = prev.next.next;
        }
        this.size--;
        return removeNode.element;
    };
    // 查看元素的索引
    // 找到返回元素的索引，否则返回-1
    indexOf(element) {
        let node = this.first;
        for (let i = 0; i < this.size; i++) {
            if (node.element == element) {
                return i;
            }
            node = node.next;

        }
        return -1;
    };
    // 检测是否越界访问
    checkLink(index) {
        if (index < 0 || index >= this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
    checkLinkAdd(index) {
        if (index < 0 || index > this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
}


exports.LinkList = LinkList
```

`element.js`

```js
class Node {
    constructor(element, next) {
        this.element = element;
        this.next = next;
    }
}

exports.Node = Node
```

`index.js`使用链表

```js
const { LinkList } = require('./LinkList');

let link = new LinkList()
link.add('0')
link.add('1')
link.set(1, '222')

console.dir(link, { depth: 100 })
```

**虚拟头节点**

> 有时候为了代码更加精简，统一所有节点的处理逻辑，可以在最前面增加一个虚拟头节点（不存储真实数据）

![虚拟头节点](/medias/imges/arithmetic/virtual-link.jpg)

我们对之前的动态数组进行如下修改

```js
class VirtualLinkList {
    constructor() {
        this.size = 0;
        this.first = new Node(null, null);
    };  
    // 获取index的节点对象
    getNode(index) {
        this.checkLink(index);
        let node = this.first.next; // +
        for (let i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    };
    // 在index位置插入一个元素
    add(index, element) {
        let args = arguments.length
        if (args == 1) {
            element = index;
            index = this.size
        }
        this.checkLinkAdd(index)

        let prev = index == 0 ? this.first : this.getNode(index - 1); // +
        prev.next = new Node(element, prev.next);
        this.size++

    };
    // 返回删除的元素
    remove(index) {
        let removeNode = this.first;

        let prev = index == 0 ? this.first : this.getNode(index - 1); // +
        removeNode = prev.next;
        prev.next = prev.next.next;
        this.size--;
        return removeNode.element;
    };
}
```

**链表练习题：解题思路**

* 141_环形链表：给定一个链表，判断链表中是否有环

```js
var hasCycle = function(head) {
    if (head == null || head.next == null) return false;
    let slow = head;
    let fast = head.next;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) return true;

    }
    return false;
};
```

> 我们是用快慢指针的方法，定义一个慢指针(slot)，一个快指针(fast)，如果快指针的`fast == null || fast.next == null`就说明链表中没有环，如果`fast == slow`快慢指针相遇就说明该链表有环。

* 206_反转链表：反转一个链表
  递归版本

```js
var reverseList = function(head) {
    if (head == null || head.next == null) return head
    let newHead = reverseList(head.next);
    head.next.next = head
    head.next = null
    return newHead
};
```

> 递归的思路：我们要明确这个递归函数的作用是啥，像这道题我们明确`reverseList()`函数的作用是反正链表，那我们将`head.next`传进去，它就会返回从之前尾部开始串直到`head.next`节点，那我们就只需要考虑，head.next.next = 指向原来的head，而原来的head.next 指向空(null)即可，当然要返回`newHeader`，和给定退出递归的判断条件

​	非递归版本（迭代）

```js
var reverseList = function(head) {
    if (head == null || head.next == null) return head
    let newHead = null;
    while (head !== null) {
        let tep = head.next;
        head.next = newHead
        newHead = head
        head = tep
    }
    return newHead
};
```

> 迭代思路：我们要定义`newHead=null`和临时变量`tep`指向`head.next`，在将`head.next`指向`newHead`，在把`newHead`指向head，最后把`head`指向`tep`完成一个链表元素指向，每次完成一个元素的指向需要四个步骤，并且顺序不能替换：
>
> * tep 指向 head.next
> * head.next 指向  newHead 
> * newHead = head
> * head = tep

* 237_ 删除链表中的节点：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 **要被删除的节点** 。

```js
var deleteNode = function(node) {
    node.val = node.next.val;
    node.next = node.next.next;
};
```

> 删除思路：由于条件只有当前被删除的节点，那我们就可以采用值替换的方式删除，将要删除的节点的下一个节点的值覆盖掉要删除的节点值，在将需要删除节点的`next`指向之前下一个节点的next，也就是`node.next.next`，这样就相当于将之前需要的删除节点的下一个节点给断开引用。

**动态数据与链表的复杂度分析**

|                    | 动态数组 |      |           | 链表 |      |           |
| ------------------ | :------: | :--: | :-------: | :--: | :--: | :-------: |
|                    |   最好   | 最坏 | 平均【*】 | 最好 | 最坏 | 平均【*】 |
| add(index,element) |   O(1)   | O(n) |   O(n)    | O(1) | O(n) |   O(n)    |
| remove(index)      |   O(1)   | O(n) |   O(n)    | O(1) | O(n) |   O(n)    |
| set(index,element) |   O(1)   | O(1) |   O(1)    | O(1) | O(n) |   O(n)    |
| get(index)         |   O(1)   | O(1) |   O(1)    | O(1) | O(n) |   O(n)    |

从上表的`平均复杂度`上看，我们动态数组比链表效率高，但别忘了我们的动态数组可能存在内存的大量浪费的情况（我们可以通过数组缩容来解决），而链表则不存在此情况。

##### 2、双向链表

我们使用双向链表可以提升链表的综合性能

![双向链表](/medias/imges/arithmetic/double-link.jpg)

我们手动实现一个双向链表

`LinkList.js`

```js
// 双向链表
const { Node } = require('./element.js');
class LinkList {
    constructor() {
        this.size = 0;
        this.first = null;
        this.last = null;
    };
    //   清除元素
    clear() {
        this.size = 0;
        this.first = null;
        this.last = null;
    };
    // 元素数量
    getSize() {
        return this.size;
    };
    // 是否为空
    isEmpty() {
        return this.size == 0;
    };
    //师傅包含某个元素
    contains(element) {
        return this.indexOf(element) !== -1
    };
    // 设置index位置的元素
    // 返回原来的元素
    set(index, element) {
        let node = this.getNode(index);
        let oldElement = node.element;
        node.element = element;
        return oldElement
    };
    // 在index位置插入一个元素

    add(index, element) {

        let args = arguments.length
        if (args == 1) {
            element = index;
            index = this.size
        }
        this.checkLinkAdd(index)

        if (index == this.size) {
            let oldLast = this.last;
            this.last = new Node(oldLast, element, null);
            if (oldLast == null) { // 添加第一个元素
                this.first = this.last;
            } else {
                oldLast.next = this.last;
            }
        } else {
            let next = this.getNode(index);
            let prev = next.prev;
            let newNode = new Node(prev, element, next);
            next.prev = newNode;
            if (prev == null) { // index == 0
                this.first = newNode;
            } else {
                prev.next = newNode;
            }
        }
        this.size++

    };
    // 获取index的节点对象

    getNode(index) {
        this.checkLink(index);
        if (index << (this.size >> 1)) {
            // 从前往后找
            let node = this.first;
            for (let i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            // 从后往前找
            let node = this.last;
            for (let i = this.size - 1; i > index; i--) {
                node = node.prev
            }
            return node
        }

    };
    // 删除index的元素
    // 返回删除的元素
    remove(index) {
        let removeNode = this.getNode(index);
        let prev = removeNode.prev;
        let next = removeNode.next;

        if (prev == null) { // index == 0
            this.first = next;
        } else {
            prev.next = next;
        }
        if (next == null) { // index == this.size -1
            this.last = prev;
        } else {
            next.prev = prev;
        }

        this.size--;
        return removeNode.element;
    };
    // 查看元素的索引
    // 找到返回元素的索引，否则返回-1
    indexOf(element) {
        let node = this.first;
        for (let i = 0; i < this.size; i++) {
            if (node.element == element) {
                return i;
            }
            node = node.next;

        }
        return -1;
    };
    // 检测是否越界访问
    checkLink(index) {
        if (index < 0 || index >= this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
    checkLinkAdd(index) {
        if (index < 0 || index > this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
}

exports.LinkList = LinkList
```

`element.js`

```js
class Node {
    constructor(prev, element, next) {
        this.element = element;
        this.prev = prev;
        this.next = next;
    }
}

exports.Node = Node
```

使用`index.js`

```js
const { LinkList } = require('./LinkList');

let link = new LinkList();
link.add(11)
link.add(22)
link.add(33)
link.add(44)
link.add(0, 66)
link.remove(0)
link.remove(2)
link.remove(link.getSize() - 1)
console.dir(link, { depth: 100 })
```

**双向链表  VS 单向链表**

比较一下删除的操作数量：

![比较删除操作的数量](/medias/imges/arithmetic/remove-number.jpg)

**双向链表 VS 动态数组**

动态数组：开辟、销毁内存空间的次数相对较少，但可能造成内存空间浪费（可以通过缩容解决）

双向链表：开辟、销毁内存空间的次数相对较多，但不会造成内存空间的浪费

故可以这样做选择：

* 如果频繁在**尾部**进行 **添加、删除**操作，**动态数组、双向链表**均可选择
* 如果频繁在**头部**进行**添加、删除**操作，建议选择使用**双向链表**
* 如果有频繁的（在任意位置）添加、删除操作，建议选择使用**双向链表**
* 如果有频繁的**查询**操作（随机访问操作），建议选择使用**动态数组**

##### 3、单向循环链表

![单向循环链表](/medias/imges/arithmetic/signecyclelinkList.jpg)

> 单向循环链表：其实就是在单向链表的基础上，将尾节点的`last.next`不在指向`null`，而是指向`first`头节点，主要我们关注与`add`与`remove`方法的改写，其的特殊情况：
>
> * 往首节点插入新节点
>   * 当我们删除第一个节点的时候并且链表只有一个节点时候就返回第一个节点
> * 删除首节点
>   * 当链表节点只有一个的时候

```js
const { Node } = require('./element.js');
class LinkList {
    constructor() {
        this.size = 0;
        this.first = null;
    };
    //   清除元素
    clear() {
        this.size = 0;
        this.first = null;
    };
    // 元素数量
    getSize() {
        return this.size;
    };
    // 是否为空
    isEmpty() {
        return this.size == 0;
    };
    //师傅包含某个元素
    contains(element) {
        return this.indexOf(element) !== -1
    };
    // 设置index位置的元素
    set(index, element) {
        let node = this.getNode(index);
        let oldElement = node.element;
        node.element = element;
        return oldElement
    };
    // 在index位置插入一个元素
    add(index, element) {
        let args = arguments.length
        if (args == 1) {
            element = index;
            index = this.size
        }
        this.checkLinkAdd(index)
        // 往第一个节点添加节点
        if (index == 0) {
            let newFirst = new Node(element, this.first);
            // 特殊情况： 当我们删除第一个节点的时候并且链表只有一个节点时候就返回第一个节点
            let last = (this.size == 0) ? newFirst : this.getNode(this.size - 1);
            // 将之前最后一个节点的next节点指向新插入的第一个节点上
            last.next = newFirst;
            // 再改变this.first的指向于新添加的节点
            this.first = newFirst
        } else {
	        // 除了在首节点处添加节点
            // 1.找到要插入节点的前一个
            let prev = this.getNode(index - 1);
            // 2.在将前一个节点的next指向新节点，并且将原来的节点传入新创建的节点作为新节点的next指向
            prev.next = new Node(element, prev.next);
        }
        this.size++

    };
    // 获取index的节点对象
    getNode(index) {
        this.checkLink(index);
        let node = this.first;
        for (let i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    };
    // 删除index的元素
    // 返回删除的元素
    remove(index) {
        let removeNode = this.first;
        // 删除首节点
        if (index == 0) {
            if (this.size == 1) {
                // 当size为1 只有一个元素时就直接返回null
                this.first = null;
            } else {
                // 找到链表最后的节点
                let last = this.getNode(this.size - 1);
                // 将链表first指向之前first的下一个
                this.first = this.first.next;
                // 将之前获取链表最后的节点指向当前的链表首节点
                last.next = this.first;
            }
        } else {
            // 除了删除首节点的其他删除
            // 1.获取要删除节点的前一个
            let prev = this.getNode(index - 1);
            removeNode = prev.next;
            // 2.将前节点的next指向要删除的节点的下一个
            prev.next = prev.next.next;
        }
        this.size--;
        return removeNode.element;
    };
    // 查看元素的索引
    // 找到返回元素的索引，否则返回-1
    indexOf(element) {
        let node = this.first;
        for (let i = 0; i < this.size; i++) {
            if (node.element == element) {
                return i;
            }
            node = node.next;

        }
        return -1;
    };
    // 检测是否越界访问
    checkLink(index) {
        if (index < 0 || index >= this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
    checkLinkAdd(index) {
        if (index < 0 || index > this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
    toString() {
        let arr = [];
        let node = this.first;
        for (let i = 0; i < this.size; i++) {
            let str = `${node.element}_${node.next.element}`;
            arr.push(str);
            node = node.next;
        }
        console.log(arr);
    }
}


exports.LinkList = LinkList
```

##### 4、双向环形链表

![双向循环链表](/medias/imges/arithmetic/doublecyclelinklist.jpg)

> 双向循环链表：确实只不过在双向链表基础上，头节点的`prev`不在指向`null`，而是指向链表的尾节点`this.last`，而尾节点的`next`不在指向`null`，而是指向首节点`this.first`，主要关注`add()`与`remove()`方法，特别关注：
>
> * 往链表尾部添加节点时
>   * 当前添加是否为第一个节点
>   * 普通往尾部添加节点
> * 往链表头部或尾部删除节点时

```js
// 双向链表
const { Node } = require('./element.js');
class LinkList {
    constructor() {
        this.size = 0;
        this.first = null;
        this.last = null;
    };
    //   清除元素
    clear() {
        this.size = 0;
        this.first = null;
        this.last = null;
    };
    // 元素数量
    getSize() {
        return this.size;
    };
    // 是否为空
    isEmpty() {
        return this.size == 0;
    };
    //师傅包含某个元素
    contains(element) {
        return this.indexOf(element) !== -1
    };
    // 设置index位置的元素
    // 返回原来的元素
    set(index, element) {
        let node = this.getNode(index);
        let oldElement = node.element;
        node.element = element;
        return oldElement
    };
    // 在index位置插入一个元素

    add(index, element) {
        let args = arguments.length
        if (args == 1) {
            element = index;
            index = this.size
        }
        this.checkLinkAdd(index)
        
        if (index == this.size) {
            // 当往尾节点添加时
            // 1.取出之前的尾节点
            let oldLast = this.last;
            // 2.将尾节点指向新创建的节点，并将新节点的next指向首节点
            this.last = new Node(oldLast, element, this.first);
            if (oldLast == null) { 
                // 添加第一个节点
                // 1. 只有一个节点时，链表的头节点和尾节点都指向与它
                this.first = this.last;
                // 2.将新节点的nex，prev都指向自己，因为只有一个节点
                this.first.next = this.first;
                this.first.prev = this.first;
            } else {
                // 将之前的尾节点next指向新的尾节点
                oldLast.next = this.last;
                // 将首节点的prev指向新的尾节点 
                this.first.prev = this.last;
            }
        } else {
            // 普通添加
            // 1.取出当前index对应的节点
            let next = this.getNode(index);
            // 2.获取当前节点的前一个节点
            let prev = next.prev;
            // 3.创建新节点
            let newNode = new Node(prev, element, next);
            // 4.将之前index对应的节点的prev指向新节点
            next.prev = newNode;
            // 5.之前index对应节点前一个节点的next指向新节点
            prev.next = newNode;
            // 当往首节点添加时，要把链表头节点指向新节点
            if (index == 0) { // index == 0
                this.first = newNode;
            }
        }
        this.size++

    };
    // 获取index的节点对象

    getNode(index) {
        this.checkLink(index);
        if (index << (this.size >> 1)) {
            // 从前往后找
            let node = this.first;
            for (let i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            // 从后往前找
            let node = this.last;
            for (let i = this.size - 1; i > index; i--) {
                node = node.prev
            }
            return node
        }

    };
    // 删除index的元素
    // 返回删除的元素
    remove(index) {
        let removeNode = this.first
     
        if (this.size == 1) {
            // 当链表只有一个节点，删除就直接将链表的头/尾节点都指向null
            this.first = null;
            this.last = null;
        } else {
            // 普通删除
            removeNode = this.getNode(index);
            // 1.获取到删除节点的前一个子节点
            let prev = removeNode.prev;
            // 2.获取到删除节点的后一个子节点
            let next = removeNode.next;
            // 3.将前节点的next指向后节点
            prev.next = next;
            // 4.将后节点的prev指向前节点
            next.prev = prev;
            if (index == 0) { // index == 0 this.first == this.last 
                // 删除的是头节点时，要将链表头节点指向删除节点的后一个
                this.first = next;
            }
            if (index == this.size - 1) { // index == this.size -1 // node == last
                // 删除的是尾节点，要将链表尾节点指向删除节点的前一个
                this.last = prev;
            }
        }

        this.size--;
        return removeNode.element;
    };
    // 查看元素的索引
    // 找到返回元素的索引，否则返回-1
    indexOf(element) {
        let node = this.first;
        for (let i = 0; i < this.size; i++) {
            if (node.element == element) {
                return i;
            }
            node = node.next;

        }
        return -1;
    };
    // 检测是否越界访问
    checkLink(index) {
        if (index < 0 || index >= this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
    checkLinkAdd(index) {
        if (index < 0 || index > this.size) {
            throw new Error(`Index:${index} ; Size:${this.size}`);
        }
    }
    toString() {
        let arr = [];
        let node = this.first;
        for (let i = 0; i < this.size; i++) {
            let str = `${node.prev.element}_${node.element}_${node.next.element}`
            arr.push(str)
            node = node.next;
        }
        console.log(arr)
    }
}

exports.LinkList = LinkList
```

#### 栈（stack）

> 栈是一种特殊的线性表，只能在一端进行操作

* 往栈中添加元素，一般叫做`push`，入栈
* 从栈中移除元素，一般叫做`pop`，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素）
* 后进先出的原则，Last In First Out (LIFO)

![栈](/medias/imges/arithmetic/stack.jpg)

**接口设计：**

* getSize()  ---> 元素的数量
* isEmpty() ----> 栈是否为空
* push(element) --->  入栈
* pop() -----> 出栈
* top() ------> 获取栈顶元素
* clear() ----> 清空栈

> 栈的内部实现可以直接利用我们之前学习的数据结构：**动态数组、链表**

`stack.js`

```js
const { ArrayList } = require('./ArrayList');
class Stack {
    constructor() {
        this.list = new ArrayList();
    };
    // 获取栈节点数量
    getSize() {
        return this.list.getSize()
    };
    // 判断栈是否为空
    isEmpty() {
        return this.list.isEmpty()
    };
    // 往栈添加元素
    push(element) {
        this.list.add(element)
    };
    // 将栈顶元素弹出
    pop() {
        return this.list.remove(this.list.size - 1);
    };
    // 获取栈顶元素
    top() {
        return this.get(this.list.size - 1);
    };
    // 清除栈
    clear() {
        this.list.clear()
    }
}
exports.Stack = Stack
```

`index.js`

```js
const { Stack } = require('./stack')
let stack = new Stack();
stack.push(11)
stack.push(22)
stack.push(33)
stack.push(44)

while (!stack.isEmpty()) {
    console.log(stack.pop())
}
```

**栈的应用：浏览器的前进后退功能**

![栈的应用](/medias/imges/arithmetic/stack-apply.jpg)

**栈的练习题**

* `20_有效括号`

> 利用栈的先进后出的特性，最先入栈的最后比较

判断情况：

* 遇见左字符，将左字符入栈
* 遇见右字符
  * 如果栈是空的，说明括号无效，返回false
  * 如果栈不为空，将栈顶字符出栈，与右字符匹配
    * 如果左右字符不匹配，说明括号无效，返回false
    * 如果左右字符匹配，继续扫描下一个字符
* 所有的字符扫描完毕
  * 栈为空，说明括号有效，返回true
  * 栈不为空，说明括号无效，返回false 

```js
var isValid2 = function(s) {
    let length = s.length;
    let stack = [];
    let map = new Map();
    map.set('(', ')');
    map.set('{', '}');
    map.set('[', ']');

    for (let i = 0; i < length; i++) {
        let char = s[i];
        if (map.has(char)) {
            stack.push(char)
        } else {
            if (stack.length == 0) return false;
            let left = stack.pop();
            if (char !== map.get(left)) return false
        }
    }
    return stack.length == 0
};
console.log(isValid2('()'))
```

#### 队列（Queue）

队列是一种特殊的线性表，只能在**头尾两端**进行的操作

* 队尾（rear）：只能从队尾添加元素，一般叫做`enQueue`，入对
* 队头（front）：只能从队头移除元素，一般叫做`deQueue`，出队
* 遵循先进先出的原则，First In First Out，FIFO

![队列](/medias/imges/arithmetic/queue.jpg)

##### 1、普通队列

**队列接口设计**

* getSize() ----> 获取队列多少元素
* isEmpyt() ----> 是否为空
* clear() ---->  清空队列节点
* enQueue(element) ----> 入队
* deQueue() ------> 出队
* front() -----> 获取队列的头元素

> 队列的内部实现是否可以直接利用以前学过的数据结构？
>
> * 动态数组、链表，因为动态数组、链表对尾部删除都是O(1)，但动态数组对头部删除是O(n)，而双向链表的对头部删除也是O(1)
> * 优先使用双向链表，因为队列主要是往头尾操作元素。

**利用双向链表实现队列**

```js
const { LinkList } = require('./LinkList');
class Queue {
    constructor() {
        this.list = new LinkList();
    };
    // 获取队列元素的多少
    getSize() {
        return this.list.getSize();
    };
    // 队列是否为空
    isEmpty() {
        return this.list.isEmpty();
    };
    // 入对
    enQueue(element) {
        this.list.add(element)
    };
    // 出对
    deQueue() {
        return this.list.remove(0)
    };
    // 获取对头
    front() {
        return this.list.getNode(0);
    };
    // 清空队列
    clear() {
        this.list.clear()
    };
    // 打印队列
    toString() {
        let arr = [];
        let first = this.list.first;
        for (let i = 0; i < this.list.getSize(); i++) {
            arr.push(first.element)
            first = first.next;
        }
        console.log(arr)
    }
}
exports.Queue = Queue
```

**练习-用栈实现队列**

准备2个栈：inStack、outStack

* 入队时，push到inStack中
* 出队时
  * 如果 outStack 为空，将inStack所有元素逐一弹出，push到 outStack，在从outStack 弹出栈顶元素
  * 如果 outStack 不为空，outStack弹出栈顶元素

**232_用栈实现队列**

```js
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
    this.inStack = [];
    this.outStack = [];
};

/** 入队
 * Push element x to the back of queue. 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.inStack.push(x);
};

/** 出队
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    if (this.outStack.length == 0) {
        while (this.inStack.length !== 0) {
            this.outStack.push(this.inStack.pop());
        }
    }
    return this.outStack.pop();
};

/** 队头
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    if (this.outStack.length == 0) {
        while (this.inStack.length !== 0) {
            this.outStack.push(this.inStack.pop());
        }
    }
    return this.outStack[this.outStack.length - 1];
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return (this.inStack.length == 0 && this.outStack.length == 0)
};
```

##### 2、双端队列（Deque）

> 双端队列是能在**头尾**两端添加、删除的队列，英文是 deque 是 double ended queue 简称

**接口设计**

* enQueueRear(element) ----> 从队尾入队【默认】
* enQueueFront(element) ----> 从队头入队 
* deQueueRear() ------> 从队尾出队
* deQueueFront() ------> 从队头出队【默认】
* front() ----> 获取队头
* rear() ---->  获取队尾

```js
const { LinkList } = require('./LinkList');
class Dequeue {
    constructor() {
        this.list = new LinkList();
    };
    // 获取队列元素的多少
    getSize() {
        return this.list.getSize();
    };
    // 队列是否为空
    isEmpty() {
        return this.list.isEmpty();
    };
    // 从尾入对
    enQueueRear(element) {
        this.list.add(element)
    };
    // 从头出对
    deQueueFront() {
        return this.list.remove(0)
    };
    // 从头入对
    enQueueFront(element) {
        this.list.add(0, element)
    };
    // 从尾出对
    deQueueRear() {
        return this.list.remove(this.list.size - 1);
    };
    // 获取对头
    front() {
        return this.list.getNode(0);
    };
    // 获取对尾
    rear() {
        return this.list.getNode(this.list.size - 1);
    };
    // 清空队列
    clear() {
        this.list.clear()
    };
    // 打印队列
    toString() {
        let arr = [];
        let first = this.list.first;
        for (let i = 0; i < this.list.getSize(); i++) {
            arr.push(first.element)
            first = first.next;
        }
        console.log(arr)
    }
}
exports.Dequeue = Dequeue
```

#####3、循环队列（Circle Queue）

> 其实队列底层也可以使用动态数组实现【当前不止是动态数组可以实现，链表也行】，并且各项接口也可以优化到O(1)的时间复杂度，这个用数组实现并且优化之后的队列也叫做**循环队列**，循环队列的优点就是将队头的操作复杂度优化到`O(1)`，我们可以通过`getIndex(index)`来获取操作队头时的队列索引位置

* enQueue(element) -----> 将节点入队
* deQueue() ----> 将头节点出队
* getIndex() ----> 获取对应的头节点插入的位置缩影

```js
class CircleQueue {
    constructor() {
        this.list = new Array(10);
        this.size = 0;
        this.front = 0;
    };
    getSize() {
        return this.size;
    };
    isEmpty() {
        return this.list.length == 0;
    };
    // 从尾部入队
    enQueue(element) {
        // 判断数组是否需要扩容
        this.ensureCapacity(this.size + 1)
        // 从getIndex()获取队尾的索引
        this.list[this.getIndex(this.size)] = element;
        this.size++;
    };
    // 动态扩容
    ensureCapacity(capacity) {
        let oldCapacity = this.list.length;
        if (oldCapacity >= capacity) return

        let newCapacity = oldCapacity + (oldCapacity >> 1);
        let newArray = new Array(newCapacity);
        for (let i = 0; i < this.size; i++) {
            newArray[i] = this.list[this.getIndex(i)];
        }
        this.list = newArray;
        this.front = 0;
    };
    // 从头出队
    deQueue() {
        // 得到队头的节点
        let frontElement = this.list[this.front];
        // 将队头即节点置为空
        this.list[this.front] = null;
        // 将队头指向下一个
        this.front = this.getIndex(1);
        this.size--;
        return frontElement;
    };
    getFront() {
        return this.list[this.front];
    };
    getIndex(index) {
        index += this.front
            // return (this.front + index) % this.list.length
        return index - (index >= this.list.length ? this.list.length : 0)
    };
    clear() {
        for (let i = 0; i < this.size; i++) {
            this.list[this.getIndex(i)] = null
        }
        this.size = 0;
        this.front = 0;
    }
}

exports.CircleQueue = CircleQueue
```

index.js

```js
const { CircleQueue } = require('./CircleQueue')

let list = new CircleQueue()

for (let i = 0; i < 10; i++) {
    list.enQueue(i)
}
for (let i = 0; i < 5; i++) {
    list.deQueue()
}
for (let i = 15; i < 23; i++) {
    list.enQueue(i)
}
console.log(list) // [ 5, 6, 7, 8, 9, 15, 16, 17, 18, 19, 20, 21, 22, null,null]
```

##### 4、循环双端队列

> 在循环队列基础上，增加了从队头入队，从队尾出队

* enQueueRear(element) ----> 从队尾入队
* enQueueFront(element) ----> 从队头入队
* deQueueRear() ----> 从队尾出队
* deQueueFront() ---> 从队头出队

```js
class CircleDequeue {
    constructor() {
        this.list = new Array(10);
        this.size = 0;
        this.front = 0;
    };
    // 获取队列元素的多少
    getSize() {
        return this.size;
    };
    // 队列是否为空
    isEmpty() {
        return this.size == 0;
    };
    // 从尾入对(*)
    enQueueRear(element) {
        // 判断是否扩容
        this.ensureCapacity(this.size + 1)
        // 找到队尾索引
        this.list[this.getIndex(this.size)] = element;
        this.size++;
    };
    // 从头出对(*)
    deQueueFront() {
        // 获取队头元素
        let frontElement = this.list[this.front];
        // 将队头元素置为空
        this.list[this.front] = null;
        // 将队头指向下一个位置
        this.front = this.getIndex(1);
        this.size--;
        return frontElement;
    };
    // 从头入对
    enQueueFront(element) {
        // 判断是否扩容
        this.ensureCapacity(this.size + 1);
        // 找到队头位置
        this.front = this.getIndex(-1)
        // 将节点写入队头位置
        this.list[this.front] = element;
        this.size++;
    };
    // 从尾出对
    deQueueRear() {
        // 获取队尾位置
        let rearIndex = this.getIndex(this.size - 1);
        // 获取队尾节点
        let rearElement = this.list[rearIndex];
        // 将队尾节点置为空
        this.list[rearIndex] = null;
        this.size--;
        return rearElement
    };
    // 获取对头
    front() {
        return this.list[this.front]
    };
    // 获取对尾
    rear() {
        return this.list[this.getIndex(this.size - 1)];
    };
    // 清空队列
    clear() {
        this.list.clear()
    };
    // 打印队列
    toString() {
        let arr = [];
        console.log(this.list.length)
        for (let i = 0; i < this.list.length; i++) {
            arr.push(this.list[i])
        }
        console.log(arr)
    };
    // 动态扩容
    ensureCapacity(capacity) {
        let oldCapacity = this.list.length;
        if (oldCapacity >= capacity) return

        let newCapacity = oldCapacity + (oldCapacity >> 1);
        let newArray = new Array(newCapacity);
        for (let i = 0; i < this.size; i++) {
            newArray[i] = this.list[this.getIndex(i)];
        }
        this.list = newArray;
        this.front = 0;
    };
    getIndex(index) {
        index += this.front;
        if (index < 0) {
            return this.list.length + index;
        }
        // return index % this.list.length
        return index - (index >= this.list.length ? this.list.length : 0)
    };
    clear() {
        for (let i = 0; i < this.size; i++) {
            this.list[this.getIndex(i)] = null
        }
        this.size = 0;

        this.front = 0;
    }
}

exports.CircleDequeue = CircleDequeue
```

`index.js`

```js
const { CircleDequeue } = require('./CircleDequeue')

let circleDequeue = new CircleDequeue();
// 头 5 4 3 2 1 100 101 102 103 104 105 106 尾
// 头 8 7 6 5 4 3 2 1 100 101 102 103 104 105 106 107 108 109 null null 10 9 尾
for (let i = 0; i < 10; i++) {
    circleDequeue.enQueueFront(i + 1);
    circleDequeue.enQueueRear(i + 100);
}
// 头 null 7 6 5 4 3 2 1 100 101 102 103 104 105 106 null null null null null null null  尾
for (let i = 0; i < 3; i++) {
    circleDequeue.deQueueFront();
    circleDequeue.deQueueRear();
}
// 头 11 7 6 5 4 3 2 1 100 101 102 103 104 105 106 null null null null null null 12  尾
circleDequeue.enQueueFront(11)
circleDequeue.enQueueFront(12)
console.log(circleDequeue.list)
```

##### %运算符优化

尽量避免使用乘（*）、除（/）、模（%）、浮点数运算，效率低下

设置n，m；条件n>0，m>0，n<2m，我们就能将模运算转化为`+/-预算`

```js
n%m ===> n-(n>=m?m:0)
```

### 三、树

> 树的代码不放这上面

![树](/medias/imges/arithmetic/tree.jpg)

![生活中的树](/medias/imges/arithmetic/life-tree.jpg)

#### 树的基本概念

![树形结构](/medias/imges/arithmetic/tree-describe.jpg)

1. 节点、根节点、父节点、子节点、兄弟节点
2. 一棵树可以没有任何节点，称为**空树**
3. 一棵树可以只有一个节点，也就是只有根节点
4. 子树、左子树、右子树
5. 节点的度（degree）：子树的个数
6. 树的度：所有节点度中的最大值
7. 叶子节点（leaf）：度为0的节点
8. 非叶子节点：度不为0的节点

| 字段                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| 层数（level）        | 根节点在第1层，根节点的子节点在第2层，以此类推（有些文章也从第0层开始计算） |
| 节点的深度（depth）  | 从根节点到当前节点的唯一路径上的节点总数                     |
| 节点的高度（height） | 从当前节点到最远叶子节点的路径上的节点总数                   |
| 树的深度             | 所有节点深度中的最大值                                       |
| 树的高度             | 所有节点高度中的最大值                                       |

> **树的深度等于树的高度**

**树的分类**

| 树类   | 概念                                                       |
| ------ | ---------------------------------------------------------- |
| 有序树 | 树中任意节点的子节点之间有顺序关系                         |
| 无序树 | 树中任意节点的子节点之间没有顺序关系，它也被称为**自由树** |
| 森林   | 由 m （m>=0）棵互不相交的树组成的集合                      |

#### 二叉树（Binary Tree）

![二叉树](/medias/imges/arithmetic/binary-tree.jpg)

**二叉树性质**

![二叉树性质](/medias/imges/arithmetic/binary-treesz.jpg)

**真二叉树**

![真二叉树](/medias/imges/arithmetic/properBinaryTree.jpg)

**满二叉树**

![满二叉树](/medias/imges/arithmetic/fullBinaryTree.jpg)

**完全二叉树**

![完全二叉树](/medias/imges/arithmetic/completeBinaryTree.jpg)

完全二叉树性质

![完全二叉树性质](/medias/imges/arithmetic/completeBinaryTreeProperty1.jpg)

![完全二叉树性质](/medias/imges/arithmetic/completeBinaryTreeProperty2.jpg)

![完全二叉树性质](/medias/imges/arithmetic/completeBinaryTreeProperty3.jpg)

不是完全二叉树

![不是完全二叉树性质](/medias/imges/arithmetic/noCompleteBinaryTree.jpg)

完全二叉的面试题

![完全二叉的面试题](/medias/imges/arithmetic/completeBinaryTreeInterview.jpg)

**总结**

| 树名       | 含义                                                         | 公式                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 真二叉树   | 所有节点的度都要么为0，要么为2                               | 与二叉树公式相同                                             |
| 满二叉树   | 最后一层节点的度都为0，其他节点的度都为2                     | 第`i`层的节点数量：2^(i-1)，叶子节点的数量：2^(h-1)，总节点：2^(h)-1，高度为：h=log2(n+1) |
| 完全二叉树 | 对节点从上至下，左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应 | 高度为h，至少2^(h-1)的节点，最多2^(h)-1节点【满二叉树】，高度h=floor(log2(n)+1) |

#### 二叉搜索树（Binary Search Tree）

**二叉搜索引入思考**

![二叉搜索树引入的思考](/medias/imges/arithmetic/binarySearchTreeIdea.jpg)

![二叉搜索树](/medias/imges/arithmetic/binarySearchTree.jpg)

**二叉树的遍历**

> 遍历是数据结构中常见的操作，也就是把元素都访问一遍
>
> 线性数据结构的遍历比较简单：
>
> * 正序遍历
> * 逆序遍历

根据节点访问的顺序的不同，二叉树的常见遍历方式有4种

* 前序遍历（Preorder Traversal）：根节点、前序遍历左子树、前序遍历右子树

> 前序遍历应用：树状结构展示（注意左右子树的顺序）

* 中序遍历（Inorder Traversal）：中序遍历左子树、根节点、中序遍历右子树

> 中序遍历应用：二叉树搜索树的中序遍历按升序或者降序处理节点

* 后序遍历（Postorder Traversal）：后序遍历左子树、后序遍历右子树、根节点

> 后序遍历应用：使用与一些先子后父的操作

* 层序遍历（Level Order Traversal）：从上到下、从左到右依次访问每个节点

> 层序遍历应用：计算二叉树的高度、判断一棵树是否为完全二叉树

**根据遍历结果重构二叉树**

* 前序遍历+中序遍历
* 后序遍历+中序遍历
* 前序遍历+后序遍历
  * 如果它是一棵真二叉树（Proper Binary Tree）【度要么为2，要么为0】，结果是唯一的，不然结果不唯一

**二叉搜索的接口设计**

`binarySearchTree.js`

* getSize() -----> 获取树的节点个数
* isEmpty() ----> 判断树是否为空树
* clear() ------> 清空树中的所有节点
* add(element) ----> 往树上添加节点
* remove(element)  ----> 删除树中的节点
* contains(element) ----> 判断树是否包含该元素

> 我们需要注意的是：对于我们现在使用的二叉树来说，因为其的结构特点，并没有索引的概念。

前驱节点：中序遍历节点前的一个节点

后继节点：中序遍历节点后的一个节点

#### 二叉平衡搜索树

> 在二叉搜索树的基础上加入策略，让我们的树的高度变为最低情况，我们熟知的二叉平衡搜索树最常见的是：
>
> * AVL树
> * 红黑树

##### AVL树

* 每个节点的平衡因子只可能是`1、0、-1`（绝对值 <=1 ，如果超过1称之为“失衡”）
* 每个节点的左右子树高度不超过1
* 搜索、添加、删除的时间复杂度是 O(logn)

失衡情况：

* 添加节点导致AVL树的失衡，通过`afterAdd()`根据【LL  \  RR  \  LR  \  RL】四种情况对AVL进行失衡修复

> 添加：可能会导致所有的祖先节点都失衡，我们只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需O(1)次调整】

* 删除节点导致AVL树的失衡，通过`afterRemove()`根据 【LL \ RR \ LR \ RL 】四种情况对AVL进行失衡修复

> 删除：可能会导致父节点或祖先节点失衡（只有一个节点失衡）。当我们将其恢复平衡，可能会导致更高层的祖先节点失衡，这样子最多需要O(logn)次调整

故其的平衡复杂度：

| 操作 | 平均复杂度                           |
| ---- | ------------------------------------ |
| 搜索 | O(logn)                              |
| 添加 | O(logn)，仅需O(1)次的旋转操作        |
| 删除 | O(logn)，最多需要O(logn)次的旋转操作 |

##### 红黑树

**B树**

> B树是一种平衡的**多路**搜索树，多用于文件系统，数据库的实现，特点：
>
> * 1个节点可以存储超过2个元素，可以拥有超过2个子节点
> * 拥有二叉搜索树的一些性质
> * 平衡，每个节点的所有子树高度一致，比较矮
>
> **B树情况很多，回去看课程PPT介绍**

**红黑树**

> 也是一种自平衡的二叉搜索树，以前也叫做平衡二叉B树，完全等价于 4阶B数

* 节点是红色【RED】或者 黑色【BLACK】
* 根节点是黑色【BLACK】
* 叶子节点（外部节点，空节点）都是BLACK
* RED 节点的子节点都是 BLACK
* 从任一节点到叶子节点的所有路径都包含相同数目的BLACK节点

添加、删除都可能会导致违反上面5点性质，那么我们要进行对其修复，情况太多，回去看课程PPT

##### AVL 对比 红黑树

AVL树

* 平衡标准比较严格：每个左右子树的高度不超过1
* 最大高度 `1.44 * log2(n+2) - 1.328`【100W个节点，AVL树最大高为28】
* 搜索、添加、删除都是O(logn)复杂度，其中添加仅需要O(1)旋转调整，删除最多需要O(logn)次旋转调整

红黑树

* 平衡标准比较宽松：**没有一条路径会大于其他路径的2倍**
* 最大高度是`2 * log2(n+1)`【100W节点，红黑树最大树高40】
* 搜索、添加、删除都是O(logn)复杂度，其中添加、删除仅需要O(1)次旋转调整

建议：

* 搜索的次数远远大于插入和删除，选择`AVL树`；搜索、插入、删除数几乎差不多，选择`红黑树`
* 相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树
* 红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树

### 四、集合【Set】

* 不存放重复的元素
* 常用于去重
  * 存放新增IP，统计新增IP量
  * 存放词汇，统计词汇量

我们可以通过动态数组、链表，二叉搜索树等来实现

### 五、映射【Map】

Map在有些编程语言中也叫做字典（dictionary）

* 节点由`key-value`组成，当key相同时，进行value覆盖
* 当我们value 存储为null，那 Map 可以看做是一个 Set 

我们可以通过动态数组、链表，二叉搜索树等来实现

### 六、哈希表

**TreeMap:**

* 添加、删除、搜素的平均复杂度为：O(logn)
* key 必须具备可比较性，元素的分布是有顺序的

但在实际应用中，很多时候的需求：

* Map中存储的元素需要讲究顺序
* Map中的key不需要具备可比较性

> 不考虑顺序、不考虑key的可比较性，Map有更好的实现方案，平均时间复杂度可以达到O(1)，那就是采用哈希表来实现Map

**哈希表**

哈希表也叫做散列表（hash有`剁碎`的意思），它是【空间换时间的典型应用】，其中哈希函数也叫做散列函数，哈希表内部的数组元素，很多地方也叫作`Bucket[桶]`，整个数组叫做 Buckets 或者 Buckets Array

**哈希冲突**

哈希冲突也叫做哈希碰撞，2个不同的`Key`，经过哈希函数计算出相同的结果，导致哈希冲突

> key != key2 ，但是 hash(key1) == hash(key2)

常见的解决方法：

* 开放定址法（Open Addressing）：安装一定规则向其他地址探测，直到遇到空桶
* 再哈希法（Re-Hashing）：设计多个哈希函数
* 链地址法（Separate Chaining）：比如通过链表将同一 index的元素串起来

**JDK1.8的哈希冲突解决方案**

> 解决方案：哈希表是使用**链表+红黑树**

* 默认使用单向链表将元素串起来
* 在添加元素时，可能会由**单向链表**转为**红黑树**来存储元素：比如当哈希表容量`>=64`且单向链表的节点数量大于8时
* 当红黑树节点数量少到一定程度时，又会转为**单向链表**

**哈希函数**

> 先生成 key的哈希值【必须是整数】，在让key的哈希值跟数组的大小进行相关运算，生成一个索引值，为了提高运算效率，我们用`&`运算来代替`%`，这步运算中就会导致不同的`key`生存hash的值是相同的：
>
> 100100 & 111 = 100 
>
> 111100 & 111 = 100

```js
function hash() {
    return hash_code(key) & (table.length - 1);
}
```

### 七、堆

> 堆（Heap）：它也是一种树状的数据结构【但不要跟内存模型中的堆空间混淆】，常见的堆实现有：二叉堆（Binary Heap，完全二叉堆），多叉堆（D-heap、D-ary Heap），索引堆（Index Heap），二项堆（Binomial Heap），斐波那契堆（Fibonacci Heap），左倾堆（Leftist Heap，左式堆），斜堆（Skew Heap）

**思考：**设计一种数据结构，用来存放整数，要求提供3个接口

* 添加元素
* 获取最大值
* 删除最大值

| 数据结构              | 获取最大值 | 删除最大值 | 添加元素 |                                          |
| --------------------- | ---------- | ---------- | -------- | ---------------------------------------- |
| 动态数组\双向链表     | O(n)       | O(n)       | O(1)     |                                          |
| 有序动态数组\双向链表 | O(1)       | O(n)       | O(n)     | 每次都要全排序有点浪费。                 |
| BBST                  | O(logn)    | O(logn)    | O(logn)  | 杀鸡用了牛刀，树形结构复杂，内存开销也大 |

> 虽然上面的数据结构都能解决我们的问题，但这世界上是否还存在一种比上面更优化，更符合的数据结构呢？那当然是有的，比如：**堆**，获取最大值`O(1)`，删除最大值：`O(logn)`、添加元素：`O(logn)`

![大顶堆/小顶堆](/medias/imges/arithmetic/heap.jpg)

堆的一个重要的性质：任何节点的值总是`>=`或`<=`子节点的值

* 如果任意节点的值总是`>=`子节点的值，称为：**最大堆、大根堆、大顶堆**
* 如果任意节点的值总是`<=`子节点的值，称为：**最小对、小根堆、小顶堆*

由此可见，堆中的元素必须具备可比较性【根二叉搜索树一样】

#### 二叉堆

> 二叉堆的逻辑结构就是一棵完全二叉堆，所以也叫作**完全二叉堆**，鉴于完全二叉树的一些特性，二叉堆的底层（物理结构）**一般用数组实现即可**。索引的i的规律(n是元素数量)
>
> * 如果`i=0`，它是根节点
> * 如果`i>0`，它的父节点的索引为`Math.floor((i-1)/2)`
> * 如果`2i+1<=n-1`，它的左子节点的索引为`2i+1`
> * 如果`2i+1>n-1`，它无左子节点
> * 如果`2i+2<=n-1`，它的右子节点的索引为`2i+2`
> * 如果`2i+2>n-1`，它无右子节点

二叉堆构建大顶堆或小顶堆涉及的概念：

* 上滤：添加节点的时候，我们从底部添加，该节点要通过上滤的操作，从下往上去过滤其他节点的值比较，得出该节点应该所在的位置
* 下滤：在删除根节点的时候，我们是用其的最尾的节点去覆盖掉根节点，那么覆盖完的根节点就要通过下滤操作，从上往下与其他节点进行比较，之后得出该节点应该存放的位置

**批量建堆**

> 批量建堆：就是我们在构建堆的时候【new Heap(elements)】就将堆元素全部传了进去，并且要求我们根据这些元素建立一个堆（比如：大顶堆或小顶堆），方式有：
>
> * 自上而下的上滤【相当于添加操作，我们将每个节点都进行上滤操作】
> * 自下而上的下滤【相当于删除操作，我们将非叶子节点都进行下滤操作】

自上而下的上滤 VS 自下而上的下滤

* 自上而下的上滤 ： 所有节点的深度之和【O(nlogn)】,自下而上的下滤：所有节点的高度之和【O(n)】

这是因为：

自上而下的上滤：仅仅是叶子节点就近`n/2`个，而且每个叶子节点的深度都是`O(logn)`级别的，因此在叶子节点这一块就达到了`O(nlogn)`级别，而`O(logn)`的时间复杂度足以利用排序算法对所有节点进行全排序

自下而上的下滤：假设是满树，节点总个数为`n`，那么树高为`n=2^h-1`，所有节点的树高之和为`H(n)=O(n)`

**Tok问题**

从n个整数中，找出最大的前`k`个数【k远远小于n】，如果使用排序算法进行全排序，需要`O(nlogn)`的时间复杂度，如果使用二叉堆来解决，可以使用`O(nlogk)`的时间复杂度来解决【新建一个小顶堆】

* 新建一个小顶堆
* 扫描n个整数
  * 先将遍历到的前`k`个数放入堆中，从第`k+1`个数开始，如果大于堆顶元素，就使用`replace`操作【删除堆顶元素，将第k+1元素添加到堆中】扫描完毕后，堆中剩下的就是最大的前K个数

**如果是找出最小的前K个数呢？**

* 用大顶堆
* 如果小于堆顶元素，就使用 replace操作

### 八、优先级队列【Priority Queue】

普通的队列是 `FIFO`原则，也就是先进先出

而优先级队列则是按照`优先级高低`进行出队，比如将优先级最高的元素作为队头优先出队

根据优先队列的特点，很容易想到：**可以直接利用二叉堆作为优先队列的底层实现**，比如我们是根据优先级高的节点先出队，那么我们就可以构建出最大堆来实现优先级队列

### 九、哈夫曼树

**哈尔曼编码**

**哈尔曼树**

如何构建一棵哈夫曼树【假设n个权值】

* 以权值作为根节点构建 n 棵二叉树，组成森林
* 在森林中选出2个根节点最小的树合并，作为一棵新数的左右子树，且新树的根节点为其左右子树节点之和
* 从森林中删除刚才选取的2棵树，并将新树加入森林
* 重复 2,3步骤，直到森林只剩一棵树为止，该树即为哈夫曼树

总结：

* n 个权值构建出来的哈夫曼树拥有 n 个叶子节点
* 每个哈夫曼编码都不是另一个哈夫曼编码的前缀
* 哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近
* 带权路径长度：树中所有的叶子节点的权值乘上其到根节点的路径长度，与最终的哈夫曼编码总长度成正比关系

### 十、Trie

Tire也叫做字典树、前缀树（Prefix Tree）、单词查找树，而且其搜索字符串的效率主要跟字符串的长度有关，假设使用 Trie 存储 cat、dog、doggy、does、cast、add 六个单词

![Trie](/medias/imges/arithmetic/Trie.jpg)

> 其内部只要使用的hashMap（哈希表来做底层架构）

Trie的优点：搜索前缀的效率主要跟前缀的长度有关

Trie的缺点：需要消耗大量的内存【因为hashMap的结构较为复杂，并且构建其的内存开销大】，因此还有待改进

### 总结

| 数据结构   |                          添加(add)                           |  查找某个节点(getNode)   |                     删除(remove)                      |                             描述                             |
| ---------- | :----------------------------------------------------------: | :----------------------: | :---------------------------------------------------: | :----------------------------------------------------------: |
| 动态数组   |           往尾部添加`O(1)`，往头部或中部添加`O(n)`           |           O(n)           |          删除头节点`O(n)`，删除尾节点`O(1)`           | 当我们需要构建的数据结构是频繁对尾部操作的时候，并且想起结构简单，动态数组是一个不错的选择 |
| 链表       | 添加操作都是`O(1)`,但其是需要查找新添加节点应该在链表所在的位置，故为`O(n)` |           O(n)           |                  删除操作都是`O(1)`                   | 当我们需要要构建的数据结构频繁需要对我们的头部和尾部进行操作时候，不妨试试链表 |
| 集合       |                   跟随底层的实现的数据结构                   | 跟随底层的实现的数据结构 |               跟随底层的实现的数据结构                | 由于集合的定义是其内的值不可是重复的，我们可以使用动态数组、链表、树等来实现，其复杂度看底层实现的数据结构 |
| 映射       |                   跟随底层的实现的数据结构                   | 跟随底层的实现的数据结构 |               跟随底层的实现的数据结构                | 由于映射的定义是其内的`key-value`不可是重复的，我们是用红黑树来实现的，那么其复杂度跟随着红黑树 |
| 树         | 添加操作是`O(1)`,但其要需要查找新添加节点应该在树所在位置，故为`O(logn)` |         O(logn)          |          删除操作也是要先查找，故为`O(logn)`          | 当我们需要构建的数据结构主要用于查找的节点，操作，删除节点的话，树结构的优化是非常明显的，相对于动态数组和链表，它能将所有对节点操作的复杂度控制在`O(logn)`内，也就是**复杂度和树高呈正比**，我们可以采用二叉平衡树让我们的树的高度达到最小，例如`AVL树和红黑树`，故若我们需要的数据结构的节点是具有可比较性的，或是遍历其节点我们是要其有序输出【中序遍历】，我们可以选择树状结构 |
| 哈希表     | 其添加节点时，由于哈希表桶内的红黑树节点是有限制的，查找是可以认为是`O(1)`，故其复杂度为`O(1)` |  桶元素有限制，故为O(1)  |               查找为O(1)，复杂度为O(1)                | 相当于树来说，当我们存储的节点是不具备可比较性的，并且我们也并不需要其输出顺序是有序的，那我们可以选择哈希表。哈希表将查找、删除、添加都优化到`O(1)`级别了，但其缺点：结构复杂，内存开销比以上的所有数据结构都大。 |
| 栈         |                                                              |                          |                         O(1)                          | 栈的应用主要用于其操作子节点顺序是**先进后出**即可应用，也就是我们需要频繁操作尾节点，故此可以用动态数组和链表来作为底层实现 |
| 队列       |                                                              |                          |                         O(1)                          | 队列的应用主要用于操作子节点顺序是**先进先出**即可应用，也就是我们要频繁操作头节点，故此我们可以使用链表来实现 |
| 堆         | 添加操作都是在其尾部添加，但由于要进行上滤操作，复杂度为O(logn) |                          | 删除都是删除堆顶节点，要进行下滤操作，复杂度为O(logn) | 当我们需要构建的数据结构只需要偏排序，并且值需要操作节点中最大值/最小值这种类型我们可以选择堆，例如TopK问题【找出前k个最大树，我们可以构建最小堆来实现】。 最大堆/最小堆其逻辑类似于我们的**完全二叉树**，故其我们可以用数组作为其底层实现。 |
| 优先级队列 |      添加节点时，要进行上滤操作，故其复杂度为`O(logn)`       |                          |      删除堆顶，要进行下滤操作，故其复杂度O(logn)      | 当我们构建的数据结构需要根据子节点的权重来按顺序出队，我们可以选择优先级队列。其底层实现可以靠我们的**堆**【最大堆】来实现。每次我们将节点出队的时候就删除堆顶节点，因为其权重在最大堆中时最大的。 |
| Trie       |                     O(k)【K为字符长度】                      |   O(k)【K为字符长度】    |                  O(k)【K为字符长度】                  | Trie称为字典树，前缀树、单词查找树。其内部实现是哈希表(hashMap)，优点是其搜索字符串的效率主要跟字符串的长度有关，缺点是其结构复杂，内存开销大。 |

### 十一、并查集（Union Find）

需求分析：假设有n个村庄，有些村庄之间有连接的路，有些村庄之间并没有连接的路

设计一个数据结构，能够快速执行2个操作：

* 查询2个村庄之间是否有连接的路
* 连接2个村庄

回想我们以前学习过的数据结构：数组、链表、平衡二叉树、集合能否实现？

> 当然可以，但数组、链表的查询、连接的时间复杂度都是：O(n)，而平衡二叉树、集合平均复杂为O(logn)，但当每个村庄都不相连时，它们的时间复杂度还是O(n)，并且其结构过于复杂，我们用其来实现，就像杀鸡用了牛刀

那么我们就可以使用**并查集**这个数据结构来完成这个需求。其能够办到查询、连接的均摊时间复杂度都是`O(a(n)),a(n)<5`，非常适合解决这类连接相关的问题

**并查集**

并查集也叫作不相交集合（Disjoint Set），其核心操作是

* 查找(Find)：查找元素所在的集合（这里的集合并不是特指Set这种数据结构，是广义的数据集合）
* 合并(Union)：将两个元素所在的集合合并为一个集合

常见的2中实现思路：

* Quick Find

  * 查找（Find）的时间复杂度为`O(1)`
  * 合并（Union）的时间复杂度为`O(n)`

  > Quick Find的合并操作，是将两个元素其中一个完全嫁接到另一个元素上【嫁接全部元素是指与嫁接同一个集合的所有元素，这样导致最后的树高最多为2】

* Quick Union

  * 查找（Find）的时间复杂度为`O(logn)`，可以优化至`O(a(n)),a(n)<5`
  * 合并（Union）的时间复杂度为`O(logn)`，可以优化至`O(a(n)),a(n)<5`

  > Quick Union 的合并操作，只是找到两个元素的根节点进行操作，将其中一个的根节点嫁接到另一个根节点上

Quick Union 的优化思路

**从Union合并入手**，由于Union的过程中，可能会出现树不平衡的情况，甚至退出成链表，这样我们find的时候时间复杂度就会增加，常见的有2中优化方案

* 基于Size的优化：元素少的是嫁接到元素多的树，但这种方式也会导致树不平衡的问题，因为每一次嫁接树的高度就会+1
* 基于Rank的优化：矮的树嫁接到 高的树

**基于Find查找入手**，不管union是基于那种手段优化，合并次数多了都会使树的高度增加，导致find的操作变慢，尤其是底层的节点（因为find是不断向上找到根节点），故我们可以转而对**Find**操作优化

* 路径压缩（Path Compression）：路径压缩就是在Find向上查找时，随便将其遍历到的路径节点都摊平到根节点上，这样就会让所有节点都指向根节点，但其实现成本稍高

比路径压缩更优的2中做法，它们不仅能降低树高，实现成本也比路径压缩低，两者的效率差不多，都比路径压缩要好

* 路径分裂（Path Spliting）：使路径上的每个节点都指向祖父节点（parent的parent）
* 路径减半（Path Halving）：使路径上每隔一个节点那就指向其祖父节点（parent的parent）

**总结**

使用路径压缩、分裂 或减半 + 基于rank或者size的Quick Union的优化，可以确保每个操作的均摊时间复杂度为O(a(n))，a(n)<5

推荐并查集使用：Quick Union  + 基于rank的优化 + 路径分裂（Path Spliting）或 路径减半（Path Halving）来构建并查集数据结构

### 十二、图

* 图的基本概念
* 图的实现：邻接矩阵、邻接表
* 图的遍历：广度优先遍历，深度优先遍历
* AOV网  ----> 拓扑排序
* 生成树
  * 最小生成树
    * prim()算法：切分定理
    * kruskal算法
* 最短路径：
  * Dijkstra----> 绳子与石头 【单源短路径算法】
  * Bellman-Ford  【单源短路径算法】
  * Floyd ---->【 多源短路径算法】