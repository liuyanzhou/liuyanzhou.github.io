---
title: 01_MYSQL_索引篇
date: 2020-06-05 23:20:20
categories: mysql
img: /medias/imges/mysql/mysql.jpg
top: false
summary: 01_MYSQL_索引篇
tags: 
 - mysql
---

#### 一、MYSQL索引简介

>   MYSQL官方对索引的定义为：索引(index)是帮助MYSQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下的**示意图**所示：[这里只是对比一下有建立索引的表和无建立索引的表，并不是说索引结构就是二叉树结构，索引数据结构在下面在听小编徐徐说来😁]

![对比示意图](/medias/imges/mysql/suoyin/1.jpg)

* 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。
* 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。
* 在强调一次: 这里只是对比一下有建立索引的表和无建立索引的表，并不是说索引结构就是二叉树结构，因为不同存储引擎支持索引的数据结构不一样，下面会讲

#### 二、为何要学习索引以及优劣势

> 在上面的简介中我们能够知道，索引是能够**高效**的帮助我们在大量数据的数据库中查找到我们所需要的数据，它也是我们优化**SQL**语句一个重要途径，我们何尝不想自己写的SQL语句能够高效率完成所需工作呢？那么这就是我们学习索引的`动机`

* 优势:

  1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本

  2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

* 劣势:

  1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空     间的。
  2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。  因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。

* 小编想说：📣📣📣📣   只要我们合理的建立索引，那么这些劣势微乎其微了📣📣📣📣

#### 三、存储引擎分类下的索引结构

> 不同的存储引擎下支持不同的索引结构。

索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：

* BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。
* HASH 索引：只有Memory引擎支持 ， 使用场景简单 。
* R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常
  使用较少，不做特别介绍。
* Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从
  Mysql5.6版本开始支持全文索引。

由于MYSQL中支持的存储引擎太多了，我们下面只介绍三种常见的存储引擎来说明：不同存储引擎支持不同索引结构`✔:支持 ×：不支持`

| 索引类型  |  Innodb  | MyISAM | Memory |
| :-------: | :------: | :----: | :----: |
|   BTREE   |    ✔     |   ✔    |   ✔    |
|   HASH    |    ×     |   ×    |   ✔    |
|  R-tree   |    ×     |   ✔    |   ×    |
| Full-text | 5.6之后✔ |   ✔    |   ×    |

> 正如上面对比可知：**BTREE**索引的数据结构是最为常见的一种被广大存储引擎所支持的，下面我们也是以它为例讲解。

#### 四、BTREE结构

BTree又叫多路平衡搜索树，一颗`m叉`的BTree特性如下：

* 树中每个节点最多包含m个孩子。
* 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。
* 若根节点不是叶子节点，则至少有两个孩子。
* 所有的叶子节点都在同一层。
* 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] <= n <= m-1

那`BTREE`它的结构是啥样的呢，下面我们以为`5`叉BTREE的创建过程来实例

> 以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] <= n <= m-1。所以 2 <= n <=4 。当n>4时，中间节点分裂到父节点，两边节点分裂。

插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。

**注意：插入的位置是按字母对应的ASCLL码对应着**

演变过程如下：

1). 插入前4个字母 C N G A

![步骤一](/medias/imges/mysql/suoyin/2.jpg)

2). 插入H，n>4，中间元素G字母向上分裂到新的节点

![步骤二](/medias/imges/mysql/suoyin/3.jpg)

3). 插入E，K，Q不需要分裂

![步骤三](/medias/imges/mysql/suoyin/4.jpg)

4). 插入M，中间元素M字母向上分裂到父节点G

![步骤四](/medias/imges/mysql/suoyin/5.jpg)

5). 插入F，W，L，T不需要分裂

![步骤五](/medias/imges/mysql/suoyin/6.jpg)

6). 插入Z，中间元素T向上分裂到父节点中

![步骤六](/medias/imges/mysql/suoyin/7.jpg)

7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂

![步骤七](/medias/imges/mysql/suoyin/8.jpg)

8). 最后插入S，NPQR节点n>5，中间节点Q向上分裂，但分裂后父节点DGMT的n>5，中间节点M向上分裂

![步骤八](/medias/imges/mysql/suoyin/9.jpg)

到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量
来说，BTREE的层级结构比二叉树小，因此搜索速度快。

#### 五、B+TREE 结构

B+Tree为BTree的变种，B+Tree与BTree的区别为：

1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。
2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。
3). 所有的非叶子节点都可以看作是key的索引部分。

![B+TREE结构](/medias/imges/mysql/suoyin/10.jpg)

> 由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。

#### 六、MySQL中的B+Tree

> MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。MySQL中的 B+Tree 索引结构示意图:

![MYSQL中B+TREE](/medias/imges/mysql/suoyin/11.jpg)



> 到此，我们了解到了MYSQL中真正的B+TREE索引结构是如何的，我们先得知道`BTREE`结构，在者了解`B+TREE`结构，其实B+TREE结构是BTREE结构的一种变种，它将非叶子节点都当作叶子节点的索引，将所有数据都存储在叶子节点中，最后MYSQL的BTREE索引结构是在`B+TREE`结构进行了改良，添加了区块间的指针，提交区间访问性能。

#### 七、索引分类

1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引 【NORMAL】

2） 唯一索引 ：索引列的值必须唯一，但允许有空值 【UNIQUE】

3） 复合索引 ：即一个索引包含多个列 

#### 八、索引设计原则

索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高
效的使用索引。

* 对查询频次较高，且数据量比较大的表建立索引。

* 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑
  选最常用、过滤效果最好的列的组合。

* 使用唯一索引，区分度越高，使用索引的效率越高。

* 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨
  船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低
  DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然
  会找到一个可用的索引，但无疑提高了选择的代价。

* 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效
  率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有
  效的提升MySQL访问索引的I/O效率。

* 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了
  组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。(✔)
  ```sql
  创建复合索引:
    CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);
  就相当于
    对name 创建索引 ;
    对name , email 创建了索引 ;
    对name , email, status 创建了索引 ;
  ```
  
#### 九、验证索引提升查询效率

  在我们准备的表结构tb_item 中， 一共存储了 300 万记录；

  1）根据ID查询 

  ```sql
  select * from tb_item where id = 1999\G;
  ```

  ![ 有索引查询 ](/medias/imges/mysql/suoyin/12.jpg)

  查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引； 

  ![ 有索引查询 ](/medias/imges/mysql/suoyin/13.jpg)

  2). 根据 title 进行精确查询 

  ```sql
  select * from tb_item where title = 'iphoneX 移动3G 32G941'\G;
  ```

  ![ 无索引查询 ](/medias/imges/mysql/suoyin/14.jpg)

  查看SQL语句的执行计划 ： 

  ![ 无索引查询 ](/medias/imges/mysql/suoyin/15.jpg)

  处理方案 ， 针对title字段， 创建索引 ：  

  ```sql
  create index idx_item_title on tb_item(title);
  ```

  ![ 建立索引 ](/medias/imges/mysql/suoyin/16.jpg)

  索引创建完成之后，再次进行查询  

  ![ 建立索引之后查询 ](/medias/imges/mysql/suoyin/17.jpg)

  通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 

  ![ 建立索引之后查询](/medias/imges/mysql/suoyin/18.jpg)

